[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CƠ SỞ LẬP TRÌNH",
    "section": "",
    "text": "Giới thiệu\nĐây là sách tóm tắt về lập trình được viết dựa trên ngôn ngữ lập trình C/C++. Sách được cấu trúc theo các chương. Mỗi chương gồm 2 phần: Phần lý thuyết: được tóm tắt ngắn gọn với đầy đủ ví dụ minh hoạ kèm theo. Phần bài tập: với nhiều bài tập được chia làm hai mức độ cơ bản và luyện tập nâng cao, bài tập có đánh dấu * là bài tập khó dành cho sinh viên luyện tập thêm.",
    "crumbs": [
      "Giới thiệu"
    ]
  },
  {
    "objectID": "chapter-1-cpp.html",
    "href": "chapter-1-cpp.html",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "",
    "text": "1.1 KHÁI NIỆM LẬP TRÌNH",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1-cpp.html#khái-niệm-lập-trình",
    "href": "chapter-1-cpp.html#khái-niệm-lập-trình",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "",
    "text": "CPU của máy tính được thiết kế để có thể thực hiện được các chương trình mã máy ) đã được hệ điều hành (HĐH) nạp vào RAM của máy tính.\nChương trình mã máy thường phải tương thích với từng họ máy cụ thể, bao gồm tập hợp các chỉ thị được viết bằng các lệnh CPU của họ máy đó, được lưu trên đĩa dưới dạng một tập tin mã thực thi của HĐH cụ thể\n\n\n\nQuy trình thực hiện\n\nBước 1: Người sử dụng ra lệnh thực hiện chạy chương trình.\nBước 2: HĐH nhận được lệnh sẽ thực hiện:\n\nTìm và nạp tập tin mã thực thi của chương trình (nằm trên đĩa) vào RAM của máy tính.\nBộ đếm lệnh của CPU (CPU program counter) được trỏ đến lệnh đầu tiên của chương trình hay còn gọi là ngõ vào chương trình\n\nBước 3: CPU thực hiện từng chỉ thị một trong RAM cho đến khi gặp lệnh kết thúc:\n\nChép lệnh mã máy hiện hành vào thanh ghi lệnh.\nTăng bộ đếm lệnh (để trỏ đến lệnh kế tiếp).\nThi hành lệnh mã máy.\n\nBước 4: Kết thúc thực hiện chương trình, HĐH chờ nhận lệnh mới.\n\n\n\nĐặc điểm\n\nMỗi chỉ thị của chương trình là một lệnh mã máy (một dãy các byte chỉ phù hợp với qui ước tập lệnh của một loại CPU nào đó)\nĐược cấu trúc hóa theo qui ước của HĐH.\nĐược chạy trên một họ CPU và HĐH cụ thể.\nNội dung rất khó hiểu đối với người dùng máy tính, chỉ có CPU thích hợp với hiểu rõ và thi hành được.\n\n\n\nNhận xét\n\nKhó có thể sản xuất ra phần mềm bằng cách viết trực tiếp các chương trình mã máy.\nNếu có làm được theo cách này thì\n\nGiá cả sẽ rất đắt do quá khó, tốn quá nhiều thời gian và công sức.\nKhả năng dùng lại rất giới hạn do không thể bán chongười dùng trên họ máy tính khác hay người dùng sử dụng hệ điều hành khác.\n\n\n\n\nNgôn ngữ lập trình - NNLT là ngôn ngữ được lập trình viên sử dụng để viết chương trình cho máy tính.\nKhi một chương trình được viết bằng một NNLT nào đó thì các chỉ thị, câu lệnh trong chương trình phải tuân theo các qui tắc, các luật do NNLT đó qui định.\nChương trình viết bằng ngôn ngữ lập trình được gọi là chương trình nguồn hay mã nguồn. Chương trình nguồn được dịch sang chương trình mã máy bằng cách chương trình dịch:\n\nTrình hợp dịch để dịch các chương trình hợp ngữ.\nTrình thông dịch và trình biên dịch để dịch các chương trình cấp cao.\n\n\n\n\nMột số ngôn ngữ lập trình thông dụng\n\nNgôn ngữ cấp thấp: Hợp ngữ (assembly language)\nNgôn ngữ cấp cao: C/C++, Java, C#, Pascal, Python, PHP, Ruby, Perl, Lisp\n\n\n\n\nChương trình là một dãy các chỉ thị điều khiển sự hoạt động của máy tính nhằm giải quyết một công việc nào đó.\nNgười viết chương trình hay còn gọi là lập trình viên hay thảo chương viên là những người tạo lập ra những chương trình máy tính.\n\n\n\nMột số chương trình\n\nNgôn ngữ assembly\n\n.model tiny\n.code\norg 100h\n    main  proc\n        mov    ah,9\n        mov    dx,offset hello_message\n        int    21h\n        retn\n        hello_message db 'Hello, world!$'\n    main endp\nend main\n\nNgôn ngữ C/C++\n\n#include &lt;stdio.h&gt;\nvoid main(void)\n{\n    pritnf(\"Hello world!\");\n}\n\nNgôn ngữ Java\n\npublic class Hello {\n    public static void main(String argv[])\n    {\n        System.out.print(\"Hello everybody!\");\n    }\n}\n\n\n\nĐặc điểm ngôn ngữ lập trình cấp thấp\n\nLà NNLT phụ thuộc vào từng họ máy cụ thể, vì vậy không có tính tương thích.\nDễ viết, đọc, sửa hơn chương trình mã máy.\nƯu điểm là tận dụng và khai thác được tính năng của mỗi họ máy cụ thể, nhờ vậy chương trình có thể chạy nhanh hơn.\n\n\n\nĐặc điểm ngôn ngữ lập trình cấp cao\n\nĐược đề xuất để khắc phục các hạn chế của NNLT cấp thấp.\nDễ dùng và dễ diễn đạt được các ý tưởng trừu tượng.\nCó tính tương thích cao (khi thay đổi dạng máy tính thì chỉ cần sửa chương trình rất ít hoặc thậm chí không cần sửa mà vẫn đảm bảo chạy đúng).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1-cpp.html#công-nghệ-lập-trình-truyền-thống",
    "href": "chapter-1-cpp.html#công-nghệ-lập-trình-truyền-thống",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.2 CÔNG NGHỆ LẬP TRÌNH TRUYỀN THỐNG",
    "text": "1.2 CÔNG NGHỆ LẬP TRÌNH TRUYỀN THỐNG\nĐối với các NNLT cấp cao truyền thống (trước thế hệ của C++, Java và C#), quá trình viết, dịch và chạy chương trình gồm các công đoạn như sau:\n\nB1. Soạn chương trình nguồn và lưu lên đĩa.\nB2. Dịch chương trình nguồn nhờ trình biên dịch.\nB3. Nối kết các tập tin mã trung gian tạo ra ở B2.\nB4. Chạy chương trình ngôn ngữ máy tạo ra ở B3.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1-cpp.html#công-nghệ-lập-trình-hiện-đại",
    "href": "chapter-1-cpp.html#công-nghệ-lập-trình-hiện-đại",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.3 CÔNG NGHỆ LẬP TRÌNH HIỆN ĐẠI",
    "text": "1.3 CÔNG NGHỆ LẬP TRÌNH HIỆN ĐẠI\n\nHạn chế của các chương trình cấp cao truyền thống là trình biên dịch của chúng phát sinh trực tiếp mã thực thi phụ thuộc vào mã máy tính của một họ máy tính và hệ điều hành cụ thể nên không thể mang đi sử dụng ở các hệ điều hành khác.\nNNLT hiện đại như Java hay C# trình biên dịch không dịch trực tiếp mã nguồn thành mã thực thi mà được thiết kế để có thể dịch thành mã thực thi trừu tượng độc lập máy và hệ điều hành.\nDo máy tính thật không thể hiểu được mã trừu tượng nên những chương trình dạng mã thực thi trừu tượng chỉ chạy được khi có sẵn máy ảo hỗ trợ cho việc thi hành loại mã thực thi đó.\nTrong các năm gần đây, các ứng dụng chạy trên web phát triển rất mạnh.\n\nChạy trên internet thông qua một trình duyệt web.\nĐược viết bằng các ngôn ngữ như Python, PHP, ASP.NET, JSP, Java Script, VB Script… có tính tương thích cao, hoạt động trên bất kỳ máy tính nào có internet\n\n\n\nCông cụ và môi trường lập trình\nToàn bộ qui trình biên dịch được thực một cách dễ dàng và thuận tiện nhờ vào công cụ gọi là môi trường phát triển phần mềm - IDE\n\nSoạn thảo chương trình.\nQuản lý hệ thống tập tin mã nguồn.\nQuản lý hệ thống các phiên bản của mã nguồn.\nKiểm tra lỗi cú pháp (syntax error), biên dịch (compile), liên kết chương trình (link).\nChạy từng dòng lệnh (debug) để tìm lỗi.\n\n\nMột số IDE thông dụng\n\nEclipse: hỗ trợ nhiều ngôn ngữ lập trình.\nVisual Studio, Visual Studio Code: hỗ trợ nghiều ngôn ngữ lập trình",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1-cpp.html#thuật-toán",
    "href": "chapter-1-cpp.html#thuật-toán",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.4 THUẬT TOÁN",
    "text": "1.4 THUẬT TOÁN\n\nCác bước thiết kế chương trình\n\nXác định bài toán\nPhân tích bài toán\nThiết kế thuật toán\nCài đặt chương trình\nKiểm thử chương trình\n\n\nThuật toán là tập hợp hữu hạn các chỉ thị được định nghĩa rõ ràng nhằm giải quyết một vấn đề cụ thể nào đó.\n\nMột thuật toán phải có các tính chất sau\n\nTính chính xác: quá trình tính toán hay các thao tác máy tính thực hiện là chính xác.\nTính rõ ràng: các câu lệnh minh bạch được sắp xếp theo thứ tự nhất định.\nTính khách quan: được viết bởi nhiều người trên máy tính nhưng kết quả phải như nhau.\nTính phổ dụng: có thể áp dụng cho một lớp các bài toán có đầu vào tương tự nhau.\nTính kết thúc: hữu hạn các bước tính toán\n\n\n\nTrình bày thuật toán như thế nào?\n\nTrình bày bằng ngôn ngữ tự nhiên\nTrình bày bằng mã giả\nTrình bày bằng lưu đồ\n\n\nHãy trình bày cách làm món sữa dâu bằng ngôn ngữ tự nhiên\nCách 1\n\nLấy một ít sữa.\nĐổ nước ép dâu vào.\nTrộn hỗn hợp này và làm lạnh.\n\nCách 2\n\nRót một ly sữa vào máy xay\nĐổ thêm vào một ít nước dâu ép\nĐóng nắm máy xay\nMở điện và bắt đầu trộn\nDừng máy trộn lại\nNếu đã trộn đều thì tắt máy, ngược lại thì trộn tiếp\nKhi đã trộn xong, rót hỗn hợp vào tô và đặt vào tủ lạnh\nĐể lạnh một lúc rồi lấy ra dùng\n\n\n\nHãy trình bày cách sắp xếp một dãy số L theo thứ tự tăng dần bằng ngôn ngữ mã giả\nMERGESORT(L)\nif SIZE(L)&gt; 1\n  SPLIT(L, L_{1}, L_{2}) (tách dãy L thành L_{1} và L_{2})\n  MERGESORT(L_{1}) (sắp xếp dãy L_{1})\n  MERGESORT(L_{2}) (sắp xếp dãy L_{2})\n  MERGE(L_{1}, L_{2}, L) (trộn dãy L_{1} và L_{2} thành L)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-2-cpp.html",
    "href": "chapter-2-cpp.html",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "",
    "text": "2.1 LÝ THUYẾT\nChương này sẽ trình bày các ký hiệu biểu diễn lưu đồ thuật toán, cách biểu diễn các cấu trúc điều khiển rẽ nhánh, cấu trúc lặp và các kỹ thuật liên quan đến lưu đồ thuật toán.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2-cpp.html#lý-thuyết",
    "href": "chapter-2-cpp.html#lý-thuyết",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "",
    "text": "Khái niệm\nLưu đồ thuật toán là công cụ đồ thị dùng để biểu diễn thuật toán, việc mô tả nhập dữ liệu và xuất dữ liệu và xử lý dữ liệu thông qua các ký hiệu hình học.\n\n\nPhần mềm công cụ\nCác công cụ để vẽ lưu đồ như\n\nDrawio, Visio\nFlowchart có thể thực thi\n\n\n\nCác ký hiệu\n\n\n\nLệnh\nKý hiệu\nLệnh\nKý hiệu\n\n\n\n\nAssignment\n\nFor\n\n\n\nCall\n\nIf\n\n\n\nComment\n\nInput\n\n\n\nDeclare\n\nOutput\n\n\n\nDo\n\nWhile\n\n\n\n\n\n\nPhương pháp vẽ và thực thi\n\nVẽ từ trên xuống\nChạy bắt đầu từ Main và kết thúc tại End\nĐi theo hướng mũi tên\n\n\n\nCác cấu trúc điều khiển cơ bản\n\nCấu trúc tuần tự\nTuần tự thực thi tiến trình. Mỗi lệnh được thực thi theo một chuỗi từ trên xuống, xong lệnh này rồi chuyển xuống lệnh kế tiếp.\n\nNhập vào một số nguyên a và xuất ra màn hình với giá trị tăng lên 1\n\n\n\nCấu trúc rẽ nhánh\nĐiểm quyết định cho phép chọn một trong hai trường hợp đúng hay sai\n\nNhập vào số nguyên n. Kiểm tra nếu n&gt;0 tăng n lên 1 đơn vị\n\n\n\nCấu trúc lặp\nThực hiện liên tục 1 lệnh hay tập lệnh với số lần lặp dựa vào điều kiện. Lặp sẽ kết thúc khi điều kiện được thỏa.\n\nNhập vào số nguyên n. Xuất ra màn hình từ 1 đến n.\n\n\n\nCác ví dụ thực hành\n\nGiải và biện luận phương trình: ax+b=0.\nTính tổng: S(n)=1+2+3+\\ldots+n với n&gt;0\nTính tổng: S(n)=\\frac{1}{2}+\\frac{2}{3}+\\frac{3}{4}+\\ldots+\\frac{2n+1}{2n+2} với n&gt;0\nTính tổng: S(n)=1-2+3-\\ldots+(-1)^{n+1}n với n&gt;0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2-cpp.html#bài-tập",
    "href": "chapter-2-cpp.html#bài-tập",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "2.2 BÀI TẬP",
    "text": "2.2 BÀI TẬP\n\nBài tập cơ bản\n\nNhập vào hai số x,y. Xuất ra màn hình tổng, hiệu, tích, thương của hai số trên.\nNhập vào số nguyên n, kiểm tra xem n chẵn hay lẻ và xuất ra màn hình.\nNhập vào ba cạnh a,b,c của tam giác. Xuất ra màn hình tam giác đó thuộc loại tam giác gì? (thường, cân, vuông, đều hay vuông cân).\nNhập vào số nguyên n. Xuất n ra màn hình (nếu n chẵn thì gấp đôi giá trị).\nNhập vào số nguyên n. Nếu n&gt;5 thì tăng n lên 2 đơn vị và trả về giá trị n, ngược lại trả về giá trị 0.\nTính n!, với n\\geq0\nTính P(n)=1.3.5...(2n+1), với n\\geq0\nTính S(n)=1+3+5+...+(2n+1), với n\\geq0\nTính S(n)=1-2+3-4+...+(-1)^{n+1}n, với n&gt;0\nTính S(n)=1+1.2+1.2.3+...+1.2.3...n, với n&gt;0\nTính S(n)=1^{2}+2^{2}+3^{2}+...+n^{2}, với n&gt;0\nTính S(n)=1+\\frac{1}{2}+\\frac{1}{3}+...+\\frac{1}{n} với n&gt;0\n(*) Tính S(n)=1+\\frac{1}{1+2}+\\frac{1}{1+2+3}+...+\\frac{1}{1+2+3+...+n} với n&gt;0\nTính P(x,y)=x^{y}\nTính S(n)=1+(1+2)+(1+2+3)+...+(1+2+3+...+n) với n&gt;0\nCho số nguyên n. Tính trị tuyệt đối của n.\nCho số nguyên dương n gồm k chữ số. Tìm chữ số có giá trị lớn nhất.\nĐếm số lượng ước số chẵn của số nguyên dương n.\nIn ra chữ số đầu tiên của số nguyên dương n gồm k chữ số.\nCho 2 số nguyên dương a,b. Tìm USCLN của a và b.\nCho 2 số nguyên dương a,b. Tìm BSCNN của a và b.\nCho số nguyên dương x. Kiểm tra xem x có phải là số nguyên tố không?\nCho số nguyên dương x. Kiểm tra x có phải là số chính phương không?\nCho số nguyên dương x. Kiểm tra xem x có phải là số hoàn thiện không?\n\n\n\nBài tập luyện tập và nâng cao\n\nTính S(n)=1+2^{2}+3^{3}+...+n^{n}, với n&gt;0\nTính S(n)=\\frac{1}{2}+\\frac{2}{3}+...+\\frac{n}{n+1} với n&gt;0\nTính S(n)=1+\\frac{1}{2!}+\\frac{1}{3!}+\\ldots.+\\frac{1}{n!} với n&gt;0\nTính S(n)=1+\\frac{1+2}{2!}+\\frac{1+2+3}{3!}+\\ldots.+\\frac{1+2+3+...+n}{n!} với n&gt;0\nGiải và biện luận phương trình bậc hai ax^{2}+bx+c=0\nGiải và biện luận phương trình trùng phương bậc bốn ax^{4}+bx^{2}+c=0\n(*) Tính S(n)=\\sqrt{n+\\sqrt{n-1+\\sqrt{n-2+...+\\sqrt{1}}}} với n&gt;0\n(**) Tính S(n)=\\sqrt{1+\\sqrt{2+\\sqrt{3+...+\\sqrt{n}}}} với n&gt;0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2-cpp.html#tóm-tắt",
    "href": "chapter-2-cpp.html#tóm-tắt",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "2.3 TÓM TẮT",
    "text": "2.3 TÓM TẮT\nLưu đồ thuật toán rất là một công cụ hữu ích trong việc mô tả cách giải quyết của một bài toán. Việc mô tả này rất trực quan thông qua các ký hiệu hình học, đây là giai đoạn đầu tiên trước khi bắt tay vào lập trình trên một ngôn ngữ lập trình cụ thể. Khi xây dựng lưu đồ thuật toán, chúng ta cần chú ý một vài điểm sau: Một lưu đồ phải có điểm bắt đầu và điểm kết thúc. Phải có dữ liệu vào, dữ liệu ra sau khi xử lý tính toán. Tại mỗi vị trí quyết định lựa chọn rẽ nhánh phải ghi rõ điều kiện đúng hoặc sai thì đi theo nhánh nào.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-3-cpp.html",
    "href": "chapter-3-cpp.html",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "",
    "text": "3.1 LÝ THUYẾT\nChương này trình bày các kiểu dữ liệu cơ bản và các phép toán tương ứng trong ngôn ngữ C++, các cấu trúc rẽ nhánh, lặp. Mô tả cách hoạt động và hướng dẫn chạy từng bước chương trình.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3-cpp.html#lý-thuyết",
    "href": "chapter-3-cpp.html#lý-thuyết",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "",
    "text": "Cấu trúc một chương trình C++ đơn giản\n\nKhai báo thư viện\nKhai báo biến toàn cục\nChương trình chính (main)\n\n\nMột chương trình đơn giản\n// Khai báo thư viện\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Khai báo biến toàn cục\nint a, b;\n\n// Chương trình chính\nint main()\n{\n    cout &lt;&lt; \"Hello world!\";\n    return 0;\n}\n\n\n\nCác kiểu dữ liệu cơ bản trong C++\n\nKiểu số nguyên\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nchar\n1\n\n\nunsigned char\n1\n\n\nint\n4\n\n\nunsigned int\n4\n\n\nlong\n8\n\n\nunsigned long\n8\n\n\n\n\n\nKiểu số thực\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nfloat\n4\n\n\ndouble\n8\n\n\n\n\n\nKiểu ký tự\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nchar\n1\n\n\nunsigned char\n1\n\n\n\n\n\nKiểu luận lý\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nbool\n1\n\n\n\n\n\n\nCác phép toán\n\nPhép toán số học\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nCộng\n+\na+b\n\n\nTrừ\n-\na-b\n\n\nNhân\n*\na*b\n\n\nChia\n/\na/b\n\n\nDư\n%\na%b\n\n\n\n\n\nphép toán so sánh\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nLớn hơn\n&gt;\na&gt;b\n\n\nNhỏ hơn\n&lt;\na&lt;b\n\n\nBằng\n==\na==b\n\n\nKhác\n!=\na!=b\n\n\nLớn hơn hoặc bằng\n&gt;=\na&gt;=b\n\n\nNhỏ hơn hoặc bằng\n&lt;=\na&lt;=b\n\n\n\n\n\nphép toán logic\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nphủ định\n!\n!a\n\n\nvà\n&&\na&&b\n\n\nhay\n||\na||b\n\n\n\n\n\nphép toán thao tác trên bit\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nNOT\n~\n~a\n\n\nAND\n&\na&b\n\n\nOR\n|\na|b\n\n\nXOR\n^\na^b\n\n\nSHIFT LEFT\n&lt;&lt;\na&lt;&lt;b\n\n\nSHIFT RIGHT\n&gt;&gt;\na&gt;&gt;b\n\n\n\n\n\nphép toán tăng giảm\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nTăng biến một đơn vị\n++\na++ hoặc ++a\n\n\nGiảm biến một đơn vị\n--\na-- hoặc --a\n\n\n\n\n\nphép toán gán và gán mở rộng\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nGán biến một giá trị\n=\na=b\n\n\n\n\ntoán tử điều kiện\n\n\n\nPhép toán\nC++\nVí dụ\n\n\n\n\nđiều kiện\n?:\na?b:c\n\n\n\n\n\n\nđộ ưu tiên và kết hợp của các toán tử\n\n\n\nLoại\nToán tử\nKết hợp\n\n\n\n\nPostfix\n() [] -&gt;. ++ --\ntrái sang phải\n\n\nUnary\n+ - ! ~ ++ -- (type)* & sizeof\nphải sang trái\n\n\nMultiplicative\n* / %\ntrái sang phải\n\n\nAdditive\n+ -\ntrái sang phải\n\n\nShift\n&lt;&lt; &gt;&gt;\ntrái sang phải\n\n\nRelational\n&lt; &lt;= &gt; &gt;=\ntrái sang phải\n\n\nEquality\n== !=\ntrái sang phải\n\n\nBitwise AND\n&\ntrái sang phải\n\n\nBitwise XOR\n^\ntrái sang phải\n\n\nBitwise OR\n|\ntrái sang phải\n\n\nLogical AND\n&&\ntrái sang phải\n\n\nLogical OR\n||\ntrái sang phải\n\n\nConditional\n?:\nphải sang trái\n\n\nAssignment\n= += -= *= /= %= &gt;&gt;= &lt;&lt;= &= ^= |=\nphải sang trái\n\n\nComma\n,\ntrái sang phải\n\n\n\n\n\n\nCác hàm thư viện cơ bản\n\nThư viện xuất nhập chuẩn &lt;iostream&gt;\n\n\nThư viện toán học &lt;cmath&gt;\n\n\n\nTên hàm\nÝ nghĩa\n\n\n\n\nabs(x)\n|a|\n\n\nsin(x)\nsin(x)\n\n\ncos(x)\ncos(x)\n\n\npow(x,y)\nx^{y}\n\n\nsqrt(x)\n\\sqrt{x}\n\n\nlog(x)\nlog(x)\n\n\nexp(x)\ne^{x}\n\n\n\n\n\n\nCấu trúc tuần tự\n\n⟨lệnh 1⟩;\n⟨lệnh 2⟩;\n...\n⟨lệnh n⟩;\nCác câu lệnh được thực hiện từ trên xuống, bắt đầu từ ⟨lệnh 1⟩, ⟨lệnh 2⟩ và cuối cùng là ⟨lệnh n⟩\n\n\nTính tổng hai số nguyên\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int a, b, s;\n    cout &lt;&lt; \"Nhap a va b = \";\n    cin &gt;&gt; a &gt;&gt; b;\n    s = a + b;\n    cout &lt;&lt; \"tong la = \" &lt;&lt; s;\n    return 0;\n}\n\n\n\nCấu trúc rẽ nhánh\n\nCâu lệnh if\n\nif (⟨biểu thức điều kiện⟩)\n{\n    ⟨khối lệnh⟩\n}\nNếu ⟨biểu thức điều kiện⟩ đúng thì thực hiện ⟨khối lệnh⟩. Lưu ý, ⟨biểu thức điều kiện⟩ phải được đặt trong cặp ngoặc\n\n\nKiểm tra một số có lớn hơn 6\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    float number;\n    cout &lt;&lt; \"Nhap mot so trong khoang tu 1 den 10 = \";\n    cin &gt;&gt; number;\n    if (number &gt; 6) {\n        cout &lt;&lt; \"So ban nhap lon hon 6.\" &lt;&lt; endl;\n    }\n    cout &lt;&lt; number &lt;&lt; \" la so ban nhap.\";\n    return 0;\n}\n\n\n\nCâu lệnh if … else\n\nif (⟨biểu thức điều kiện⟩)\n{\n    ⟨khối lệnh 1⟩\n}\nelse\n{\n    ⟨khối lệnh 2⟩\n}\nNếu ⟨biểu thức điều kiện⟩ cho kết quả đúng thì thực hiện ⟨khối lệnh 1⟩, ngược lại thì cho thực hiện ⟨khối lệnh 2⟩.\n\n\nGiải và biện luận phương trình ax+b=0\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    float a, b;\n    cout &lt;&lt; \"Nhap vao a: \";\n    cin &gt;&gt; a;\n    cout &lt;&lt; \"Nhap vao b: \";\n    cin &gt;&gt; b;\n    if (a == 0) {\n        if (b == 0) {\n            cout &lt;&lt; \"Phuong trinh vo so nghiem\";\n        }\n        else {\n            cout &lt;&lt; \"Phuong trinh vo nghiem\";\n        }\n    }\n    else {\n        cout &lt;&lt; \"Nghiem phuong trinh x = \" &lt;&lt; -b / a;\n    }\n    return 0;\n}\n\n\n\nCâu lệnh switch\n\nswitch (⟨biểu thức số⟩)\n{\n    case ⟨n_1⟩: ⟨các câu lệnh 1⟩; break;\n    case ⟨n_2⟩: ⟨các câu lệnh 2⟩; break;\n    ...\n    case ⟨n_k⟩: ⟨các câu lệnh k⟩; break;\n    [default: ⟨các câu lệnh k+1⟩;]\n}\n\nKhi giá trị biểu thức bằng n_{i} thì thực hiện câu lệnh sau case ⟨n_i⟩.\nKhi giá trị biểu thức không thỏa tất cả các n_{i} thì thực hiện câu lệnh sau default nếu có, hoặc thoát khỏi câu lệnh switch.\nKhi chương trình đã thực hiện xong câu lệnh của case ⟨n_i⟩ nào đó thì nó sẽ thực hiện luôn các lệnh thuộc case bên dưới nó mà không xét lại điều kiện (do các n_i được xem như các nhãn) Vì vậy, để chương trình thoát khỏi lệnh switch sau khi thực hiện xong một trường hợp, ta dùng lệnh break.\n\n\n\nTạo thực đơn và cho phép chọn thực đơn bằng số nhập từ bàn phím.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int chon;\n    cout &lt;&lt; \"Thuc Don\" &lt;&lt; endl;\n    cout &lt;&lt; \"1. Lau thai!\" &lt;&lt; endl;\n    cout &lt;&lt; \"2. Nuoc ngot!\" &lt;&lt; endl;\n    cout &lt;&lt; \"3. Ca loc hap bau!\" &lt;&lt; endl;\n    cout &lt;&lt; \"4. Chuot dong!\" &lt;&lt; endl;\n    cout &lt;&lt; \"Xin moi ban chon mon an: \";\n    cin &gt;&gt; chon;\n    switch (chon)\n    {\n        case 1: cout &lt;&lt; endl &lt;&lt; \"Ban chon lau thai!\"; break;\n        case 2: cout &lt;&lt; endl &lt;&lt; \"Ban chon nuoc ngot!\"; break;\n        case 3: cout &lt;&lt; endl &lt;&lt; \"Ban chon ca loc hap bau!\"; break;\n        case 4: cout &lt;&lt; endl &lt;&lt; \"Ban chon chuot dong!\"; break;\n        default: cout &lt;&lt; endl &lt;&lt; \"Ban chon khong dung!\"; break;\n    }\n    return 0;\n}\n\n\n\n\nCấu trúc lặp\n\nCâu lệnh for\n\nfor (⟨biểu thức 1⟩; ⟨biểu thức 2⟩; ⟨biểu thức 3⟩)\n{\n    ⟨các câu lệnh⟩\n}\nHoạt động của câu lệnh for như sau:\n\nBước 1: Khởi gán cho ⟨biểu thức 1⟩\nBước 2: Kiểm tra điều kiện của ⟨biểu thức 2⟩\n\nNếu ⟨biểu thức 2⟩ đúng thì cho thực hiện ⟨các câu lệnh⟩ và thực hiện ⟨biểu thức 3⟩ rồi quay trở lại bước 2.\nNgược lại thì thoát khỏi lặp.\n\nBất kỳ biểu thức nào trong 3 biểu thức nói trên đều có thể vắng nhưng phải giữ dấu chấm phẩy (;)\n\n\n\nIn ra màn hình bảng mã ASCII từ ký tự số 32 đến 255.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    for (int i = 32; i &lt;= 255; i++) {\n        cout &lt;&lt; \"Ma ASCII cua \" &lt;&lt; (char)i &lt;&lt; \": \" &lt;&lt; i &lt;&lt; \"\\t\";\n    }\n    return 0;\n}\n\n\n\nCâu lệnh while\n\nwhile (⟨biểu thức điều kiện⟩)\n{\n    ⟨các câu lệnh⟩\n}\nNếu ⟨biểu thức điều kiện⟩ đúng thì thực hiện ⟨các câu lệnh⟩ và lặp điều này cho đến khi nào ⟨biểu thức điều kiện⟩ sai thì kết thúc\n\n\nIn ra các chữ số của số nguyên n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int n, chuso;\n    cout &lt;&lt; \"Nhap vao n = \";\n    cin &gt;&gt; n;\n    while (n &gt; 0)\n    {\n        chuso = n % 10;\n        cout &lt;&lt; chuso &lt;&lt; \" \";\n        n = n / 10;\n    }\n    return 0;\n}\n\n\n\nCâu lệnh do … while\n\ndo {\n    ⟨các câu lệnh⟩\n} while (⟨biểu thức điều kiện⟩);\nThực hiện khối lệnh cho đến khi ⟨biểu thức điều kiện⟩ có giá trị sai.\n\n\nNhập ký tự từ bàn phím hiển thị lên màn hình mã ASCII của ký tự đó, thực hiện đến khi nhấn phím ESC (Mã ASCII của phím ESC là 27).\n#include &lt;iostream&gt;\n#include &lt;conio.h&gt; // Lưu ý: conio.h không phải là thư viện chuẩn của C++\nusing namespace std;\n\nint main()\n{\n    int ma;\n    cout &lt;&lt; \"Nhan mot phim bat ky (Nhan ESC de thoat):\" &lt;&lt; endl;\n    do {\n        ma = getch();\n        if (ma != 27) {\n            cout &lt;&lt; \"Ma ASCII \" &lt;&lt; (char)ma &lt;&lt; \": \" &lt;&lt; ma &lt;&lt; \"\\t\";\n        }\n    } while (ma != 27);\n    return 0;\n}\n\n\nLệnh lặp while kiểm tra điều kiện trước khi thực hiện lặp, còn lệnh lặp do...while thực hiện lệnh lặp rồi mới kiểm tra điều kiện. Do đó vòng lặp do...while thực hiện ⟨các câu lệnh⟩ ít nhất một lần.\n\n\n\nCâu lệnh break và continue\nLệnh break dùng để kết thúc vòng lặp trực tiếp chứa nó\n\nCho phép người dùng nhập liên tục giá trị n cho đến khi nhập số âm thì dừng lại\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int n;\n    while (true)\n    {\n        cout &lt;&lt; \"Nhap n = \";\n        cin &gt;&gt; n;\n        if (n &lt; 0) {\n            break;\n        }\n    }\n    return 0;\n}\n\nLệnh continue dùng để bỏ qua một lần lặp.\n\nIn ra màn hình giá trị từ 1 đến 25 trừ đi số 14 và số 18.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    for (int i = 1; i &lt;= 25; i++)\n    {\n        if (i == 14 || i == 18) {\n            continue;\n        }\n        cout &lt;&lt; i &lt;&lt; \"\\t\";\n    }\n    return 0;\n}\n\n\n\n\nCấu trúc nhảy\n\n⟨nhãn⟩:\n...\ngoto ⟨nhãn⟩;\n...\ncon trỏ lệnh sẽ được nhảy đến vị trị của ⟨nhãn⟩\n\n\nKiểm tra một số nguyên là số dương, âm hay không?\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int n;\n    cout &lt;&lt; \"Nhap vao so nguyen = \";\n    cin &gt;&gt; n;\n    if (n &gt; 0) goto nhan1;\n    if (n &lt; 0) goto nhan2;\n    if (n == 0) goto nhan3;\nnhan1:\n    cout &lt;&lt; \"so duong\";\n    goto nhan;\nnhan2:\n    cout &lt;&lt; \"so am\";\n    goto nhan;\nnhan3:\n    cout &lt;&lt; \"so khong\";\nnhan:\n    return 0;\n}\n\n\n\nThực thi chương trình\n\nXác định các biến trong chương trình.\nGiá trị ban đầu của mỗi biến.\nThực hiện chạy chương trình theo đúng trình tự đã được viết\n\n\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int i, a = 4;\n    for (i = 0; i &lt; a; i++) {\n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n    return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3-cpp.html#bài-tập",
    "href": "chapter-3-cpp.html#bài-tập",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "3.2 BÀI TẬP",
    "text": "3.2 BÀI TẬP\n\nBài tập cơ bản\n\n\nBiến, biểu thức và toán tử\n\nChuỗi ký tự nào sau đây không thể là tên biến được?\n\n\n\n\nBASICSALARY\n_basic\nbasic-hra\n\n\n#MEAN\ngroup.\n422\n\n\npopulation in 2006\nover time\nmindovermatter\n\n\nFLOAT\nhELLO\nqueue.\n\n\nteam'svictory\nPlot # 3\n2015_DDay\n\n\nnhiệt\nvan_toc\nlai suat\n\n\n\n\nChỉ ra biểu thức C/C++ lỗi (nếu có)\n\nint = 314.562 * 150;\nname = 'Ajay';\nvarchar = '3';\n3.14 * r * r * h = vol_of_cyl;\nk = ( a * b ) ( c + ( 2.5a + b ) ( d + e );\nm_inst = rate of interest * amount in rs;\nsi = principal * rateofinterest * numberofyears / 100;\narea = 3.14 * r ** 2;\nvolume = 3.14 * r ^ 2 * h;\nk = ( (a * b ) + c ) ( 2.5 * a + b );\na = b = 3 = 4;\ncount = count + 1;\ndate = '2 Mar 04';\n\nXác định thứ tự thực hiện các phép toán và tính giá trị của biểu thức\n\ng = big / 2 + big * 4 / big - big + abc / 3; (abc = 2.5, big = 2, giả sử g có kiểu float)\non = ink * act / 2 + 3 / 2 * act + 2 + tig; (ink = 4, act = 1, tig = 3.2, giả sử on có kiểu int)\ns = qui * add / 4 - 6 / 2 + 2 / 3 * 6 / god; (qui = 4, add = 2, god = 2, giả sử s có kiểu int)\ns = 1 / 3 * a / 4 - 6 / 2 + 2 / 3 * 6 / g; (a = 4, g = 3, giả sử s có kiểu int)\n\nXác định toán hạng cho các phép toán trong biểu thức\n\ng = 10 / 5 / 2 / 1;\nb = 3 / 2 + 5 * 4 / 3;\na = b = c = 3 + 4;\n\nChuyển các biểu thức toán sau sang ngôn ngữ C/C++ A=\\frac{\\frac{8.8(a+b)2}{c}-0.5+\\frac{2a}{q+r}}{\\frac{a+b}{m}} B=\\frac{-b+\\sqrt{b^{2}-4ac}}{2a} C=\\frac{2v+6.22(c+d)}{g+v} D=\\frac{\\frac{7.7b(xy+a)}{c}-0.8+2b}{\\frac{x+a}{y}}\n\n\n\nCấu trúc rẽ nhánh\n\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 9, b = 6;\n    a++;\n    a = a + b--;\n    a = a + (--b);\n    if (a % 2 == 0) {\n        cout &lt;&lt; \"Gia tri cua a la chan\";\n    }\n    cout &lt;&lt; \"Tong cua a va b la: \" &lt;&lt; a + b;\n    return 0;\n}\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 7, b = 8;\n    a++;\n    a = a + (b--);\n    --b;\n    a--;\n    a = (--a) + (--b);\n    if (a % 2 != 0) {\n        cout &lt;&lt; endl &lt;&lt; \"a la so le\";\n    }\n    else {\n        cout &lt;&lt; endl &lt;&lt; \"a la so chan\";\n    }\n    cout &lt;&lt; endl &lt;&lt; \"a = \" &lt;&lt; a;\n    return 0;\n}\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5, y;\n    y = x++ + 5;\n    cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; endl;\n    y *= 6;\n    x = y % 7;\n    cout &lt;&lt; \"x=\" &lt;&lt; x &lt;&lt; \",y=\" &lt;&lt; y &lt;&lt; \",y/x=\" &lt;&lt; y / x;\n    return 0;\n}\nNhập vào hai số nguyên a,b. In ra màn hình giá trị lớn nhất.\nCho ba số a,b,c đọc vào từ bàn phím. Hãy tìm giá trị lớn nhất của ba số trên và in ra kết quả.\nCho ba số a,b,c đọc vào từ bàn phím. Hãy in ra màn hình theo thứ tự tăng dần các số. (Chỉ được dùng thêm hai biến phụ).\nViết chương trình nhập vào một số nguyên n gồm ba chữ số. Xuất ra màn hình chữ số lớn nhất ở vị trí nào? Ví dụ: n=291. Chữ số lớn nhất nằm ở hàng chục là 9.\nViết chương trình nhập vào số nguyên n gồm ba chữ số. Xuất ra màn hình theo thứ tự tăng dần của các chữ số. Ví dụ: n=291. Xuất ra 129.\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không? In kết quả ra màn hình.\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không? In kết quả ra màn hình.\nViết chương trình nhập vào ngày, tháng, năm hợp lệ. Cho biết năm này có phải là năm nhuận hay không? In kết quả ra màn hình.\nViết chương trình tính diện tích và chu vi các hình: tam giác, hình vuông, hình chữ nhật và hình tròn với những thông tin cần được nhập từ bàn phím.\nViết chương trình tính tiền cước TAXI. Biết rằng:\n\nkm đầu tiên giá là 5000đ\n200m tiếp theo là 1000đ.\nNếu lớn hơn 30km thì mỗi km thêm sẽ là 3000đ\n\nHãy nhập số km sau đó in ra số tiền phải trả.\nNhập vào 3 số nguyên dương a,b,c. Kiểm tra xem 3 số đó có lập thành tam giác không? Nếu có hãy cho biết tam giác đó thuộc loại nào? (cân, vuông, đều, …).\nViết chương trình nhập vào số nguyên dương n. Kiểm tra xem n có phải là số chính phương hay không? (số chính phương là số khi lấy căn bặc 2 có kết quả là nguyên).\n\n\n\nCấu trúc lặp\n\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 18;\n    for (int i = 1; i &lt;= a; i++) {\n        if (a % i == 0) {\n            cout &lt;&lt; \"\\t\" &lt;&lt; i;\n        }\n    }\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    for (int i = 0; i &lt; 5; i++)\n    {\n        for (int j = 0; j &lt;= i; j++) {\n            cout &lt;&lt; j &lt;&lt; \"\\t\";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 10, s = 0;\n    while (i &gt; 0)\n    {\n        if (i % 2 == 0) {\n            s += i;\n        }\n        else {\n            if (i &gt; 5) {\n                s += 2 * i;\n            }\n        }\n        i--;\n    }\n    cout &lt;&lt; \"s = \" &lt;&lt; s;\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 18, i = 1;\n    do {\n        if (a % i == 0) {\n            cout &lt;&lt; \"\\t\" &lt;&lt; i;\n        }\n        i++;\n    } while (i &lt;= a);\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 11, b = 16, i = a;\n    while (i &lt; b)\n    {\n        if (i % 2 == 0)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; i;\n            break;\n        }\n        i++;\n    }\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 10, s = 0, i = 0;\n    while (i &lt; a)\n    {\n        i++;\n        if (i % 2 == 0) {\n            continue;\n        }\n        else {\n            s = s + i;\n        }\n    }\n    cout &lt;&lt; \"s=\" &lt;&lt; s;\n    return 0;\n}\nCho biết kết quả của đọan chương trình sau:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int i = 1, s = 0;\n    while (true)\n    {\n        s = s + i++;\n        if (i % 2) {\n            i = i + 2;\n        }\n        else {\n            i = i + 1;\n        }\n        if (i &gt; 20) break;\n    }\n    cout &lt;&lt; s;\n    return 0;\n}\nViết chương trình in ra màn hình hình chữ nhật đặc kích thước m\\times n. Ví dụ: Nhập m=5,n=4\n* * * * \n* * * * \n* * * * \n* * * * \n* * * *\nViết chương trình in ra màn hình hình chữ nhật rỗng kích thước m\\times n. Ví dụ: Nhập m=5,n=4\n* * * * \n*     * \n*     * \n*     * \n* * * *\nViết chương trình in ra màn hình tam giác vuông cân đặc có độ cao h. Ví dụ: Nhập h=4\n* \n* * \n* * * \n* * * * \nViết chương trình in ra màn hình tam giác cân rỗng có độ cao h. Ví dụ: Nhập h=4\n* \n* * \n*   * \n* * * * \nViết chương trình in ra màn hình tam giác cân đặc có độ cao h. Ví dụ: Nhập h=4\n      *\n    * * *\n  * * * * *\n* * * * * * * \nViết chương trình in ra màn hình tam giác cân rỗng có độ cao h. Ví dụ: Nhập h=4\n      *\n    *   *\n  *       *\n* * * * * * *\nViết chương trình nhập số nguyên dương n. Liệt kê n số nguyên tố đầu tiên.\nViết chương trình nhập vào hai số nguyên dương a và b. Tìm ước số chung lớn nhất và bội số chung nhỏ nhất của a và b.\nViết chương trình nhập vào một số nguyên n gồm tối đa 10 chữ số (4 bytes). In ra màn hình giá trị nhị phân của số trên.\nViết chương trình đếm số ước số của số nguyên dương n. Ví dụ: n=12 số ước số của 12 là 6\nMột số hoàn thiện là một số có tổng các ước số của nó (không kể nó) bằng chính nó. Hãy liệt kê các số hoàn thiện nhỏ hơn 5000. Ví dụ: số 6 là số hòan thiện vì tổng các ước số là 1+2+3=6.\nNhập vào ngày, tháng, năm. Cho biết đó là ngày thứ mấy trong năm.\nIn ra dãy số Fibo f_{n} f_{n}=\\begin{cases}\n1 & n=1\\\\\n1 & n=2\\\\\nf_{n-1}+f_{n-2} & n&gt;2\n\\end{cases}\n\n\n\nBài tập luyện tập và nâng cao\n\nCài đặt tất cả các lưu đồ đã vẽ ở chương 1.\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không, nếu hợp lệ cho biết ngày sau đó là bao nhiêu. Ví dụ: Nhập 31/12/2003 Ngày sau đó 01/01/2004\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không, nếu hợp lệ cho biết ngày trước đó là bao nhiêu. Ví dụ: Nhập 01/01/2003 Ngày trước đó 31/12/2002\n(*) Nhập vào ngày, tháng, năm của năm 2003. Hãy kiểm tra xem dữ liệu có hợp lệ hay không? Nếu hợp lệ hãy cho biết đó là ngày thứ mấy trong tuần. (hai, ba, tư, …, CN).(Hướng dẫn: lấy ngày 01 tháng 01 năm 2003 là ngày thứ tư làm mốc).\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không, nếu hợp lệ cho biết giờ sau đó 1 giây là bao nhiêu. Ví dụ: Nhập 01:59:59 Giờ sau đó 1 giây 02:00:00\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không, nếu hợp lệ cho biết giờ trước đó 1 giây là bao nhiêu. Ví dụ: Nhập 02:00:00 Giờ trước đó 1 giây 01:59:59\nViết chương trình in ra bảng cửu chương từ 2 đến 9.\n(*) Vẽ hình cánh quạt sau với h là chiều dài cánh quạt. Ví dụ h=4\n*     * * * *\n* *   * * *    \n* * * * *\n* * * * * * *\n    * * * * * \n  * * *   * *\n* * * *     *",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3-cpp.html#tóm-tắt",
    "href": "chapter-3-cpp.html#tóm-tắt",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "3.3 TÓM TẮT",
    "text": "3.3 TÓM TẮT\nCấu trúc tuần tự, lặp và rẽ nhánh (lựa chọn) là ba cấu trúc chính hình thành nên chương trình. Dựa vào những cấu trúc điều khiển này ta có thể xây dựng thành những chương trình phức tạp hơn. Vì vậy phải nắm rõ cách hoạt động của những cấu trúc điều khiển này để cài đặt đúng yêu cầu bài toán. Khi sử dụng phải lưu ý điều kiện thực hiện hay kết thúc của một thao tác nào đó. Bên trong một phát biểu điều khiển phải là một lệnh hay một khối lệnh (khối lệnh được đặt bên trong cặp dấu ngoặc {}). Những biến không phụ thuộc vào vòng lặp nên đặt bên ngoài vòng lặp. Khi sử dụng cấu trúc điều khiển lồng nhau phải lưu ý vị trí mở ngoặc hay đóng ngoặc cho hợp lý.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-4-cpp.html",
    "href": "chapter-4-cpp.html",
    "title": "4  HÀM",
    "section": "",
    "text": "4.1 LÝ THUYẾT\nChương này trình bày cấu trúc của một chương trình, các bước xây dựng cài đặt chương trình theo phương pháp thủ tục hàm và một số kỹ thuật liên quan.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4-cpp.html#lý-thuyết",
    "href": "chapter-4-cpp.html#lý-thuyết",
    "title": "4  HÀM",
    "section": "",
    "text": "Khái niệm\nHàm là một đoạn chương trình độc lập thực hiện trọn vẹn một công việc nhất định sau đó trả về giá trị cho chương trình gọi nó, hay nói cách khác hàm là sự chia nhỏ của chương trình. Hàm được sử dụng khi:\n\nCó một công việc giống nhau cần thực hiện ở nhiều lúc khác nhau.\nKhi cần chia một chương trình lớn phức tạp thành các chương trình nhỏ để dễ quản lý việc tính toán và giải quyết vấn đề cũng như dễ hiểu.\n\n\nMột chương trình có sử dụng hàm đơn giản\n// Khai báo thư viện\n#include &lt;iostream&gt;\n\n// Khai báo hàm (nguyên mẫu hàm)\nfloat LuyThua(float x, int n);\n\n// Hàm chính\nint main()\n{\n    float x, y;\n    int n;\n    std::cout &lt;&lt; \"Nhap x va n =\";\n    std::cin &gt;&gt; x &gt;&gt; n;\n    y = LuyThua(x, n);\n    // In kết quả ra màn hình (tùy chọn)\n    std::cout &lt;&lt; \"Ket qua: \" &lt;&lt; y &lt;&lt; std::endl;\n    return 0;\n}\n\n// Cài đặt (định nghĩa) hàm\nfloat LuyThua(float x, int n)\n{\n    float y = 1;\n    for(int i = 1; i &lt;= n; i++)\n        y = y * x;\n    return y;\n}\n\n\n\nCấu trúc một chương trình C++\n\nPhần khai báo\nBao gồm các:\n\nKhai báo thư viện sử dụng\nKhai báo hằng số\nKhai báo kiểu dữ liệu tự định nghĩa\nKhai báo các biến toàn cục\nKhai báo các hàm hay nguyên mẫu hàm\n\n\n\nHàm chính main\nThực hiện các công việc và các lời gọi hàm cần thiết.\n\n\nCác hàm\nThực hiện các công việc xác định.\n\n\n\nCách xây dựng một hàm con\n\nKhai báo hàm\n\n⟨Kiểu dữ liệu trả về của hàm⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩);\nLưu ý: tham số trong nguyên mẫu hàm có thể bỏ phần tên.\n\n\n\nCài đặt hàm\n\n⟨Kiểu dữ liệu trả về của hàm⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{\n    ⟨các câu lệnh⟩\n}\n\n\n\nGọi hay thực thi hàm\n\n⟨Tên hàm⟩(⟨danh sách các tham số được truyền⟩);\n\nCó 3 cách truyền tham số:\n\nTruyền bằng giá trị\n\nTham số gọi là tham trị.\nTruyền đối số cho hàm ở dạng giá trị.\nCó thể truyền hằng, biến, biểu thức.\nĐược sử dụng khi không có nhu cầu thay đổi giá trị của tham số sau khi thực hiện hàm.\n\nvoid Ham(int x)\n{\n    // ...\n    int y = x;\n    // ...\n}\n\nint main()\n{\n    int a, b;\n    // ...\n    Ham(3);\n    Ham(a);\n    Ham(a + b);\n    // ...\n    return 0;\n}\nTruyền bằng địa chỉ\n\nTham số gọi là tham trỏ.\nTruyền đối số cho hàm ở dạng địa chỉ (con trỏ).\nChỉ truyền đối số là biến.\nĐược sử dụng khi có nhu cầu thay đổi hoặc nhận giá trị của đối số sau khi thực hiện hàm.\n\nvoid Ham(int *x)\n{\n    // ...\n    int y = *x;\n    // ...\n}\n\nint main()\n{\n    int a;\n    // ...\n    Ham(&a);\n    // ...\n    return 0;\n}\nTruyền bằng tham chiếu\n\nTham số gọi là tham biến.\nTruyền đối số cho hàm ở dạng tham chiếu.\nChỉ truyền đối số là biến.\nĐược sử dụng khi có nhu cầu thay đổi hoặc nhận giá trị của đối số sau khi thực hiện hàm.\n\nvoid Ham(int &x)\n{\n    // ...\n    int y = x;\n    // ...\n}\n\nint main()\n{\n    int a;\n    // ...\n    Ham(a);\n    // ...\n    return 0;\n}\n\n\n\nXác định kiểu dữ liệu trả về của hàm\nXác định dựa vào đầu ra của hàm. Gồm 2 loại:\n\nHàm không trả về giá trị: Những hàm loại này thường rơi vào những nhóm chức năng: nhập/xuất dữ liệu, thống kê, sắp xếp, liệt kê.\n\nvoid ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{\n    ⟨Khai báo các biến cục bộ⟩\n    ⟨Các câu lệnh hay lời gọi hàm⟩\n}\n\nHàm trả về kiểu dữ liệu cơ bản hay kiểu dữ liệu có cấu trúc: Kiểu dữ liệu tùy theo mục đích của hàm cần trả về giá trị gì thông qua việc phân tích bài toán. Những hàm loại này thường được sử dụng trong các trường hợp: Đếm, kiểm tra, tìm kiếm, tính trung bình, tổng, tích, …\n\n⟨Kiểu dữ liệu⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{\n    ⟨Kiểu dữ liệu⟩ kq;\n    ⟨Khai báo các biến cục bộ⟩\n    ⟨Các câu lệnh hay lời gọi hàm⟩\n    return kq;\n}\n\n\nĐối với những hàm trả về nhiều loại giá trị cho từng trường hợp cụ thể (chẳng hạn như kiểm tra: đúng hay sai, so sánh: bằng, lớn hơn hay nhỏ hơn, …) thì cần ghi chú rõ giá trị trả về là gì cho từng trường hợp đó.\n\n\nXác định tham số\nXác định dựa vào đầu vào của hàm. Lưu ý:\n\nTham số dạng tham trị: Không thay đổi hoặc không cần lấy giá trị mới của tham số sau lời gọi hàm. Tham số dạng này chỉ mang ý nghĩa là dữ liệu đầu vào.\nTham số dạng tham trỏ và tham biến: Có sự thay đổi giá trị của tham số trong quá trình thực hiện và cần lấy lại giá trị đó sau khi ra khỏi hàm. Ứng dụng của tham số loại này có thể là dữ liệu đầu ra (kết quả) hoặc cũng có thể vừa là dữ liệu đầu vào vừa là dữ liệu đầu ra.\n\n\n\nXác định biến cục bộ\nLà các đại lượng trung gian được sử dụng trong hàm.\n\n\nXác định tên hàm\nĐặt tên theo quy ước đặt tên trong C++ sao cho tên gọi đúng với chức năng hay mục đích thực hiện của hàm và gợi nhớ.\n\n\nCác ví dụ\n\nViết hàm in ra màn hình các ước số của n.\nPhân tích hàm:\n\nInput: n là số nguyên dương\nOutput: không có\nCông việc: In ra các ước số của số của n\n\n#include &lt;iostream&gt;\n\nvoid LietKeUocSo(unsigned int n)\n{\n    for(int i = 1; i &lt;= n; i++)\n        if(n % i == 0)\n            std::cout &lt;&lt; i &lt;&lt; \"\\t\";\n}\n\n\nViết hàm tính tổng S(n)=1+2+3+\\ldots+n, với n là số nguyên dương.\nPhân tích bài toán:\n\nInput: n là số nguyên dương\nOutput: S là tổng của 1+2+3+...+n\nCông việc: Tính tổng S\n\nunsigned int TongS(unsigned int n)\n{\n    unsigned int S = 0;\n    int i = 1;\n    while(i &lt;= n)\n    {\n        S += i;\n        i++;\n    }\n    return S;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4-cpp.html#bài-tập",
    "href": "chapter-4-cpp.html#bài-tập",
    "title": "4  HÀM",
    "section": "4.2 BÀI TẬP",
    "text": "4.2 BÀI TẬP\n\nBài tập cơ bản\n\nCài đặt lại tất cả các bài tập ở chương 2 theo phương pháp hàm.\nViết chương trình tính diện tích và chu vi của hình chữ nhật với chiều dài và chiều rộng được nhập từ bàn phím.\nViết chương trình tính diện tích và chu vi hình tròn với bán kính được nhập từ bàn phím.\nNhập số nguyên dương n. Liệt kê tất cả các số nguyên tố nhỏ hơn n.\nNhập số nguyên dương n. Liệt kê n số chính phương đầu tiên.\nNhập số nguyên dương n. Đếm xem có bao nhiêu số hoàn thiện nhỏ hơn n.\nNhập số nguyên dương n (0&lt;n&lt;1000) và in ra cách đọc của n. Ví dụ: Nhập n = 105. In ra màn hình: mot tram le nam.\nViết chương trình tính tiền thuê máy dịch vụ Internet và in ra màn hình kết quả. Với dữ liệu nhập vào là giờ bắt đầu thuê (GBD), giờ kết thúc thuê (GKT), số máy thuê (SoMay).\n\nĐiều kiện cho dữ liệu nhập: 6\\leq GBD &lt; GKT \\leq 21. Giờ là số nguyên.\nĐơn giá: 2500đ cho mỗi giờ máy trước 17:30 và 3000đ cho mỗi giờ máy sau 17:30.\n\nViết chương trình tính tiền lương ngày cho công nhân, cho biết trước giờ vào ca, giờ ra ca của mỗi người. Giả sử rằng:\n\nTiền trả cho mỗi giờ trước 12 giờ là 6000đ và sau 12 giờ là 7500đ.\nGiờ vào ca sớm nhất là 6 giờ sáng và giờ ra ca trễ nhất là 18 giờ (Giả sử giờ nhập vào nguyên).\n\nNhập vào 2 số nguyên p,q và tính biểu thức sau: \\left(-\\frac{q}{2}+\\left(\\frac{p^{3}}{27}+\\frac{q^{2}}{4}\\right)^{\\frac{1}{2}}\\right)^{\\frac{1}{3}}+\\left(-\\frac{q}{2}-\\left(\\frac{p^{3}}{27}+\\frac{q^{2}}{4}\\right)^{\\frac{1}{2}}\\right)^{\\frac{1}{3}}\nNhập vào 3 số thực a,b,c và kiểm tra xem chúng có thành lập thành 3 cạnh của một tam giác hay không? Nếu có hãy tính diện tích, chiều dài mỗi đường cao của tam giác và in kết quả ra màn hình.\n\nCông thức tính diện tích s=\\sqrt{(p*(p-a)*(p-b)*(p-c))} với p là nữa chu vi của tam giác\nCông thức tính các đường cao: h_{a}=\\frac{2s}{a},h_{b}=\\frac{2s}{b},h_{c}=\\frac{2s}{c}\n\nNhập vào 6 số thực a,b,c,d,e,f. Giải hệ phương trình sau: \\left\\{ \\begin{array}{l}\nax+by=c\\\\\ndx+ey=f\n\\end{array}\\right.\nViết chương trình nhập 2 số nguyên dương a,b. Tìm USCLN và BSCNN của hai số nguyên đó.\nViết chương trình tính tổng nghịch đảo của n giai thừa.\nCho 2 số nguyên a,b. Viết hàm hoán vị giá trị 2 số trên.\n(*) Viết chương trình nhập số nguyên dương n gồm 5 chữ số, kiểm tra xem các chữ số n có phải là số đối xứng hay không. Ví dụ: Đối xứng: 13531 Không đối xứng: 13921\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, đếm xem n có bao nhiêu chữ số chẵn và bao nhiêu chữ số lẻ.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, đếm xem n có bao nhiêu chữ số là số nguyên tố.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tính tổng các ước số dương của n. Ví dụ, nhập n=6 Tổng các ước số từ 1 đến n: 1+2+3+6=12.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tìm ước số lẻ lớn nhất của n. Ví dụ: Ước số lẻ lớn nhất của 27 là 9.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, kiểm tra xem các chữ số của n có toàn lẻ hay toàn chẵn không.\n(*) Viết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, sắp xếp các chữ số của n theo thứ tự tăng dần. Ví dụ: Nhập n=1536 Kết quả sau khi sắp xếp: 1356.\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, sau đó nhập một số nguyên x, tìm vị trí xuất hiện của chữ số có giá trị x trong n. Ví dụ: Nhập n=1526, x=2 Kết quả: Chu so 2 o vi tri thu 3.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, kiểm tra xem các chữ số của n có được sắp thứ tự không. Ví dụ, nhập n=1569 hoặc n=8521 thì kết quả là có thứ tự.\nViết chương trình nhập 2 số a,b sao cho: số lớn nhất trong 2 số phải là một số dương và chia hết cho 7. Nếu nhập sai phải yêu cầu nhập lại cho đến khi đúng.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tính giá trị trung bình các chữ số chẵn trong n.\n(*) Viết chương trình in ra màn hình ngày/tháng/năm của ngày hiện tại, cho phép sử dụng các phím mũi tên lên, xuống để tăng hoặc giảm một ngày.\n(*) Viết chương trình in ra màn hình giờ:phút:giây hiện tại, cho phép sử dụng các phím mũi tên lên, xuống để tăng hoặc giảm một giây.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4-cpp.html#tóm-tắt",
    "href": "chapter-4-cpp.html#tóm-tắt",
    "title": "4  HÀM",
    "section": "4.3 TÓM TẮT",
    "text": "4.3 TÓM TẮT\nTrước khi xây dựng một hàm ta phải xác định mục đích của hàm là dùng để làm gì, trên cơ sở đó, ta mới xác định được các thành phần của hàm và xây dựng nguyên mẫu hàm. Mỗi hàm phải thực hiện một chức năng độc lập và tách biệt với các hàm khác (không được lồng nhau). Đối với hàm có giá trị trả về phải lưu ý kiểu dữ liệu phải tương ứng kiểu dữ liệu cả giá trị trả về và kiểu dữ liệu của biến được gán khi gọi hàm. Trường hợp hàm trả về từ hai loại giá trị trở lên thì phải có dòng chú thích cho trường hợp tương ứng để khi gọi hàm biết được kết quả (chẳng hạn như tìm kiếm, kiểm tra, so sánh,.v.v giá trị trả về có 2 trường hợp: có hoặc không có phần tử cần tìm, thỏa điều kiện kiểm tra hay không? Do vậy ta phải quy ước giá trị cho từng trường hợp). Nên đặt tên hàm sao cho gợi nhớ được chức năng, đặt tên theo quy tắc nhất định để tránh việc gọi sai tên hàm do lẫn lộn giữa ký tự hoa và thường, có dấu gạch nối giữa các từ trong hàm hay không? Khi gọi hàm phải truyền đủ tham số, đúng kiểu dữ liệu và đúng thứ tự của tham số.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-5-cpp.html",
    "href": "chapter-5-cpp.html",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "",
    "text": "5.1 LÝ THUYẾT\nChương này trình bày trình bày dữ liệu kiểu mảng, các thao tác nhập xuất, các kỹ thuật thao tác trên mảng. Ứng dụng các kỹ thuật này trong việc cài đặt các hàm tìm kiếm, kiểm tra, xây dựng mảng, tách và ghép mảng.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5-cpp.html#lý-thuyết",
    "href": "chapter-5-cpp.html#lý-thuyết",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "",
    "text": "mảng một chiều là tập hợp các phần tử được lưu trữ liên tục và các phần tử của mảng phải cùng kiểu dữ liệu.\n\n\nKhai báo biến mảng\n\n⟨Kiểu dữ liệu⟩ ⟨Tên mảng⟩ [⟨Số phần tử tối đa của mảng⟩];\n\n\nKhai báo mảng a có 100 số nguyên và mảng b có 50 số thực\nint a[100]; \nfloat b[50]; \n\n\n\nTruy xuất phần tử của mảng\nVới khái niệm và cách khai báo như trên ta có hình dạng của mảng một chiều như sau:\n\n⟨Tên mảng⟩[⟨Chỉ số⟩]\n\n\nKhởi tạo và xuất mảng một chiều\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() \n{ \n    int a[4] = {5, 9, 3, 8}; \n    for(int i = 0; i &lt; 4; i++) \n        cout &lt;&lt; \"a[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; a[i] &lt;&lt; \"\\t\"; \n    return 0; \n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5-cpp.html#bài-tập",
    "href": "chapter-5-cpp.html#bài-tập",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "5.2 BÀI TẬP",
    "text": "5.2 BÀI TẬP\n\nKỹ thuật nhập xuất mảng một chiều\n\nViết chương trình nhập xuất mảng một chiều các số nguyên.\n#include &lt;iostream&gt;\nusing namespace std;\n#define MAX 100\nvoid NhapMang(int a[], int &n) \n{ \n    cout &lt;&lt; \"Nhap so phan tu: \"; \n    cin &gt;&gt; n; \n    for(int i = 0; i &lt; n; i++) \n    { \n        cout &lt;&lt; \"a[\" &lt;&lt; i &lt;&lt; \"] = \"; \n        cin &gt;&gt; a[i]; \n    } \n}\nvoid XuatMang(int a[], int n) \n{ \n    cout &lt;&lt; \"\\nNoi dung mang: \"; \n    for(int i = 0; i &lt; n; i++) \n        cout &lt;&lt; a[i] &lt;&lt; \"\\t\"; \n}\nint main() \n{ \n    int a[MAX], n; \n    NhapMang(a, n); \n    XuatMang(a, n); \n    return 0; \n}\n\n\nViết chương trình nhập xuất mảng một chiều các số thực.\nViết chương trình khởi tạo giá trị các phần tử là 0 cho mảng một chiều các số nguyên gồm n phần tử.\nViết chương trình phát sinh ngẫu nhiên mảng một chiều các số nguyên âm.\nViết chương trình phát sinh ngẫu nhiên mảng một chiều các số nguyên sao cho mảng có thứ tự tăng dần (không sắp xếp).\nViết chương trình nhập mảng các số thực và xuất các phần tử âm trong mảng.\nViết chương trình nhập mảng các số nguyên và xuất các phần tử lẻ có trong mảng.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra các phần tử chẵn nhỏ hơn 20.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra màn hình các phần tử là số nguyên tố.\nViết chương trình nhập vào số nguyên n và liệt kê các số nguyên tố nhỏ hơn n, nếu mảng không tồn tại số nguyên tố nào nhỏ hơn n thì phải xuất ra một câu thông báo.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra màn hình các phần tử là số chính phương nằm tại những vị trí lẻ trong mảng.\n\n\n\nKỹ thuật đặt cờ hiệu\nKỹ thuật này thường được áp dụng cho những bài toán kiểm tra hay đánh dấu.\n\nViết hàm kiểm tra xem mảng các số nguyên có thứ tự tăng dần không? (Trả về 1: Nếu mảng tăng dần, ngược lại trả về 0).\nint KiemTraTang(int a[], int n) \n{ \n    int flag = 1; \n    for(int i = 0; i &lt; n - 1; i++) \n        if(a[i] &gt; a[i+1]) // vi phạm điều kiện tăng dần\n        { \n            flag = 0; \n            break; \n        } \n    return flag; \n} \n\n\nViết hàm kiểm tra xem trong mảng các số nguyên có tồn tại số nguyên lẻ lớn hơn 100 hay không? (Trả về 1: Nếu có tồn tại số lẻ và lớn hơn 100, ngược lại trả về 0).\nint KiemTraLe(int a[], int n) \n{ \n    int flag = 0; \n    for(int i = 0; i &lt; n; i++) \n        if(a[i] % 2 != 0 && a[i] &gt; 100) // Gặp phần tử thoả\n        { \n            flag = 1; \n            break; \n        } \n    return flag; \n} \n\n\n\nKỹ thuật đặt lính canh\nKỹ thuật này thường được áp dụng cho những bài tập về tìm kiếm, liệt kê theo một điều kiện nhất định nào đó.\n\nViết hàm tìm và trả về giá trị lớn nhất trong mảng một chiều các số nguyên.\nint TimMax(int a[], int n) \n{ \n    int max = a[0]; \n    for(int i = 1; i &lt; n; i++) \n    { \n        if(a[i] &gt; max) \n        {\n            max = a[i]; \n        }\n    } \n    return max; \n} \n\n\n\nKỹ thuật tìm kiếm trên mảng một chiều\n\nViết hàm tìm phần tử có giá trị x xuất hiện đầu tiên trong mảng một chiều. (Nếu tìm thấy trả về vị trí xuất hiện x, ngược lại trả về -1)\nint TimX(int a[], int n, int x) \n{ \n    for(int i = 0; i &lt; n; i++) \n        if(x == a[i]) \n            return i; \n    return -1; \n} \n\n\nViết hàm tìm vị trí phần tử có giá trị x xuất hiện cuối cùng trong mảng.\nViết hàm tìm vị trí của phần tử nhỏ nhất trong mảng các số nguyên.\nViết hàm tìm vị trí của phần tử lớn nhất trong mảng các số nguyên.\nViết hàm in vị trí các phần tử nguyên tố trong mảng các số nguyên.\nViết hàm in vị trí các phần tử nguyên tố lớn hơn 23.\nViết hàm tìm vị trí phần tử âm đầu tiên trong mảng. Nếu không có phần tử âm trả về -1.\nViết hàm tìm vị trí phần tử âm lớn nhất trong mảng.\nViết hàm tìm vị trí phần tử dương đầu tiên trong mảng. Nếu không có phần tử âm trả về -1.\nViết hàm tìm vị trí phần tử dương bé nhất trong mảng.\nViết hàm in các phần tử là bội của 3 và 5.\nViết hàm tìm số chẵn cuối cùng có trong mảng, nếu không tồn tại số chẵn hàm trả về -1.\nViết hàm tìm số lẻ lớn nhất có trong mảng, n ếu không tồn tại số lẻ hàm trả về -1.\nViết hàm tìm và đổi chỗ phần tử lớn nhất với phần tử nhỏ nhất trong mảng.\nNhập vào x. Viết hàm in ra màn hình những phần tử có giá trị từ 1 đến x có trong mảng.\nViết chương trình nhập vào một dãy số a gồm n số thực và dãy số b gồm m số thực (m,n\\leq100).\n\nIn ra những phần tử chỉ xuất hiện trong dãy a mà không xuất hiện trong dãy b.\nIn ra những phần tử xuất hiện ở cả hai dãy.\n\n\n\n\nKỹ thuật đếm phần tử - tần suất\n\nViết hàm đếm các phần tử chia hết cho 5 trong mảng các số nguyên.\nint Dem(int a[], int n) \n{ \n    int dem = 0; \n    for(int i = 0; i &lt; n; i++) \n        if(a[i] % 5 == 0) \n            dem++; \n    return dem; \n} \n\n\nViết hàm đếm các phần tử âm, dương trong mảng.\nViết hàm đếm các phần tử chẵn, lẻ trong mảng.\nViết hàm đếm số lần xuất hiện của phần tử x trong mảng.\nViết hàm đếm các phần tử nhỏ hơn x trong mảng.\nViết hàm đếm các phần tử là số nguyên tố trong mảng.\nViết hàm đếm các phần tử là số hoàn thiện trong mảng.\nViết hàm đếm các phần tử là bội của 3 và 5 trong mảng các số nguyên.\n\n\n\nKỹ thuật tính tổng - trung bình\n\nViết hàm tính tổng các phần tử trong mảng.\nint TinhTong(int a[], int n) \n{ \n    int tong = 0; \n    for(int i = 0; i &lt; n; i++) \n        tong = tong + a[i]; \n    return tong; \n} \n\n\nViết hàm tính giá trị trung bình các phần tử có giá trị âm trong mảng. Đối với hàm tính trung bình có điều kiện phải lưu ý khi chia giá trị (có thể mảng không có phần tử nào thoả điều kiện, nếu ta chia tức là chia cho 0).\nfloat TinhTrungBinhAm(int a[], int n) \n{ \n    int tong = 0; \n    int spt = 0; \n    for(int i = 0; i &lt; n; i++) \n        if(a[i] &lt; 0) \n        { \n            tong = tong + a[i]; \n            spt++; \n        } \n    if(spt == 0) return 0; \n    return (float)tong / spt;\n}\n\n\nViết hàm tính tổng các phần tử chẵn trong mảng.\nViết hàm tính tổng các phần tử lẻ trong mảng các số nguyên.\nViết hàm tính tổng các phần tử nguyên tố trong mảng.\nViết hàm tính tổng các phần tử nằm ở vị trí chẵn trong mảng các số nguyên.\nViết hàm tính tổng các phần tử nằm ở vị trí nguyên tố trong mảng.\nViết hàm tính tổng các phần tử chia hết cho 5 có trong mảng.\nViết hàm tính tổng các phần tử cực đại trong mảng các số nguyên (phần tử cực đại là phần tử lớn hơn các phần tử xung quanh nó). Ví dụ: 1 5 2 6 3 5 1 8 6\nViết hàm tính tổng các phần tử cực tiểu trong mảng các số nguyên (phần tử cực tiểu là phần tử nhỏ hơn các phần tử xung quanh nó). Ví dụ: 6 4 2 9 5 3 7 1 5 8\nViết hàm tính tổng các phần tử là bội của 3 và 5 trong mảng các số nguyên.\nViết hàm tính tổng các phần tử là số hoàn thiện trong mảng các số nguyên.\nViết hàm tính giá trị trung bình của các số hoàn thiện trong mảng các số nguyên.\n\n\n\nKỹ thuật sắp xếp\n\nViết hàm sắp xếp mảng theo thứ tự tăng dần.\nvoid HoanVi(int &a, int &b) \n{ \n    int tam = a; \n    a = b; \n    b = tam; \n}\nvoid SapTang(int a[], int n) \n{ \n    for(int i = 0; i &lt; n - 1; i++) \n        for(int j = i + 1; j &lt; n; j++) \n            if(a[i] &gt; a[j]) \n                HoanVi(a[i], a[j]); \n} \n\n\nViết hàm sắp xếp mảng theo thứ tự giảm dần.\nViết hàm sắp xếp mảng theo thứ tự tăng dần của các phần tử là số nguyên tố.\nViết hàm sắp xếp các phần tử lẻ tăng dần.\nViết hàm sắp xếp các phần tử chẵn giảm dần.\nViết hàm sắp xếp các phần tử chẵn nằm bên trái theo thứ tự tăng dần còn các phần tử lẻ bên phải theo thứ tự giảm dần.\nViết hàm sắp xếp các phần tử âm giảm dần từ trái sang phải, phần tử dương tăng dần từ phải sang trái.\n\n\n\nKỹ thuật xoá phần tử\nDuyệt mảng từ trái sang phải. Xuất phát từ vị trí cần xoá tiến hành dời lần lượt các phần tử về phía trước cho đến khi kết thúc mảng, sau đó giảm kích thước mảng. Vấn đề đặt ra là tìm vị trí cần xóa theo điều kiện bài toán rồi thực hiện xóa.\n\nViết hàm xoá phần tử đầu tiên của mảng.\nvoid XoaDau(int a[], int &n) \n{ \n    for(int i = 0; i &lt; n - 1; i++) \n        a[i] = a[i+1]; \n    n--; \n} \n\n\nViết hàm xoá phần tử tại vị trí vitri cho trước trong mảng.\nvoid XoaTaiViTri(int a[], int &n, int vitri) \n{ \n    for(int i = vitri; i &lt; n - 1; i++) \n        a[i] = a[i+1]; \n    n--; \n} \n\n\nViết hàm xoá phần tử tại vị trí lẻ trong mảng.\nViết hàm xoá phần tử có giá trị lớn nhất trong mảng.\nNhập vào giá trị x. Viết hàm xoá tất cả các phần tử có giá trị nhỏ hơn x.\nNhập vào giá trị x. Viết hàm xoá phần tử có giá trị gần x nhất.\n\n\n\nKỹ thuật thêm/chèn phần tử\nDuyệt mảng từ phải sang trái. Xuất phát từ cuối mảng tiến hành đẩy lần lượt các phần tử về phía sau cho đến vị trí cần chèn, chèn phần tử cần chèn vào vị trí chèn và tăng kích thước mảng. Trước khi chèn ta phải xác định vị trí cần chèn theo điều kiện bài toán.\n\nThêm phần tử có giá trị x vào cuối mảng.\nvoid ChenCuoi(int a[], int &n, int x) \n{ \n    a[n] = x; \n    n++; \n} \n\n\nChèn phần tử có giá trị x vào mảng tại vị trí (vitri) cho trước\nvoid ChenTaiViTri(int a[], int &n, int x, int vitri) \n{ \n    for(int i = n; i &gt; vitri; i--) \n        a[i] = a[i-1]; \n    a[vitri] = x; \n    n++; \n} \n\n\nViết hàm chèn phần tử có giá trị x vào vị trí đầu tiên của mảng.\nViết hàm chèn phần tử có giá trị x vào phía sau phần tử có giá trị lớn nhất trong mảng.\nViết hàm chèn phần tử có giá trị x vào trước phần tử có giá trị là số nguyên tố đầu tiên trong mảng.\nViết hàm chèn phần tử có giá trị x vào phía sau tất cả các phần tử có giá trị chẵn trong mảng.\n\n\n\nKỹ thuật tách và ghép mảng\n\nCho mảng a kích thước n (n chẵn). Tách mảng a thành 2 mảng b và c sao cho: b có một nửa số phần tử đầu của mảng a, một nửa số phần tử còn lại đưa vào mảng c.\nvoid TachMang(int a[], int n, int b[], int &m, int c[], int &l) \n{ \n    int k = n / 2;\n    m = l = 0; \n    for(int i = 0; i &lt; k; i++) \n    { \n        b[m++] = a[i]; \n    }\n    for(int i = k; i &lt; n; i++)\n    {\n        c[l++] = a[i];\n    }\n} \n\n\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối mảng b vào cuối mảng a.\nvoid GhepMang(int a[], int &n, int b[], int m) \n{ \n    for(int i = 0; i &lt; m; i++) \n        a[n + i] = b[i]; \n    n = n + m; \n} \n\n\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối xen kẻ (đan xen) lần lượt các phần tử mảng a và b vào mảng c.\nĐưa lần lượt từng phần tử của mảng a và mảng b vào mảng c, tăng chỉ số tương ứng. Nếu một trong hai mảng hết trước thì chép tất cả các phần tử còn lại của mảng chưa hết vào mảng c. Đặt i là chỉ số của mảng a; j: chỉ số của mảng b và k là chỉ số của mảng c.\nvoid GhepMangXenKe(int a[], int n, int b[], int m, int c[], int &k) \n{ \n    int i = 0, j = 0; \n    k = 0; \n    while(i &lt; n && j &lt; m) \n    { \n        c[k++] = a[i++]; \n        c[k++] = b[j++]; \n    } \n    while(i &lt; n) \n        c[k++] = a[i++]; \n    while(j &lt; m) \n        c[k++] = b[j++]; \n} \n\n\nViết chương trình tách 1 mảng các số nguyên thành 2 mảng a và b, sao cho mảng a chứa toàn số lẻ và mảng b chứa toàn số chẵn. Ví dụ: mảng ban đầu: 1 3 8 2 7 5 9 0 10 thì mảng a: 1 3 7 5 9 và mảng b: 8 2 10\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối 2 mảng trên thành mảng c theo nguyên tắc chẵn ở đầu mảng và lẻ ở cuối mảng. Ví dụ: mảng a: 3 2 7 5 9 và mảng b: 1 8 10 4 12 6 thì mảng c: 6 12 4 10 2 8 3 1 7 5 9\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình nhập vào mảng A gồm n phần tử, trong quá trình nhập kiểm tra các phần tử nhập vào không được trùng, nếu trùng thông báo và yêu cầu nhập lại.\nViết hàm tính tổng của từng dãy con giảm có trong mảng.\n(*) Cho mảng các số nguyên a gồm n phần tử (n\\leq30000) và số dương k\\leq n. Hãy chỉ ra số hạng lớn thứ k của mảng. Ví dụ: mảng a: 6 3 1 10 11 18 và k = 2 thì kết quả là 10\n(*) Cho 2 dãy A, B các số nguyên (kích thước dãy A nhỏ hơn dãy B). Hãy kiểm tra xem A có phải là con của B hay không?\nViết hàm liệt kê các bộ 4 số a,b,c,d trong mảng các số nguyên (có ít nhất 4 phần tử và đôi một khác nhau) sao cho a+b=c+d.\n(*) Viết chương trình tính trung bình cộng của các tổng các dãy tăng dần có trong mảng các số nguyên. Ví dụ: 1 2 3 4 2 3 4 5 6 4 5 6 thì trung bình = 15.\nViết chương trình tính tổng tất cả các phần tử xung quanh trên mảng các số nguyên (phần tử xung quanh là hai phần tử bên cạnh cộng lai bằng chính nó, ví dụ: 1 3 2 thì 1, 2 là hai phần tử xung quanh của 3). Ví dụ: 1 3 2 5 3 9 6 tổng 17\n(**) Viết chương trình nhập vào hai số lớn a,b nguyên (a,b có từ 20 chữ số trở lên). Tính tổng, hiệu, tích, thương của hai số trên.\nViết hàm tính tổng các phần tử là số Amstrong (số Amstrong là số có đặc điểm như sau: số có k chữ số, tổng của các luỹ thừa bậc k của các ký số bằng chính số đó. Ví dụ: 153 là số có các ký số 1^{3}+5^{3}+3^{3}=153 là một số Amstrong).\nViết hàm tìm và xóa tất cả các phần tử trùng với x trong mảng một chiều các số nguyên, nếu không tồn tại phần tử x trong mảng thì trả về -1.\nViết hàm xoá tất cả những phần tử trùng nhau trong dãy chỉ giữ lại một phần tử trong đó. Ví dụ: 1 6 2 3 2 4 2 6 5 thì kế tquả 1 6 2 3 4 5\n(**) Viết hàm xoá những phần tử sao cho mảng kết quả có thứ tự tăng dần và số lần xoá là ít nhất.\nCho dãy a gồm n số nguyên có thứ tự tăng dần. Nhập vào một phần tử nguyên x, viết hàm chèn x vào dãy sao cho dãy vẫn có thứ tự tăng dần (không sắp xếp).\nViết chương trình tìm số lẻ nhỏ nhất lớn hơn mọi số chẵn có trong mảng.\nViết hàm tìm giá trị chẵn nhỏ nhất nhỏ hơn mọi giá trị lẻ trong mảng các số nguyên.\nViết hàm tìm phần tử xuất hiện nhiều nhất trong mảng các số nguyên.\nViết chương trình đếm và liệt kê các mảng con tăng dần trong mảng một chiều các số nguyên. Ví dụ: 6 5 3 2 3 4 2 7 các dãy con tăng dần là 2 3 4 và 2 7\nViết chương trình tìm mảng con tăng dần có tổng lớn nhất trong mảng một chiều.\n(*) Viết chương trình nhập vào một dãy số a gồm n số nguyên (n\\leq100). Tìm và in ra dãy con tăng dài nhất. Ví dụ: Nhập dãy a: 1 2 3 6 4 7 8 3 4 5 6 7 8 9 4 5 thì dãy con tăng dài nhất: 3 4 5 6 7 8 9\n(**) Viết chương trình tách 1 mảng các số nguyên thành 2 mảng a và b, sao cho kết quả thu được là:\n\nMảng a chứa toàn số lẻ tăng dần.\nMảng b chứa toàn số chẵn giảm dần\nKhông dùng thuật toán sắp xếp\n\nHướng dẫn: Tìm vị trí chèn thích hợp khi trích phần tử từ mảng ban đầu. Ví dụ: mảng ban đầu: 9 3 8 2 7 5 1 0 10 thì Mảng a: 1 3 5 7 9 Mảng b: 10 8 2\n(**) Viết chương trình in ra tam giác Pascal (dùng mảng một chiều).\nViết chương trình nhập vào dãy số a gồm n số thực (n\\leq100) và dãy số b gồm m số thực (m\\leq100).\n\nHãy sắp xếp hai dãy theo thứ tự tăng dần.\n(*) Trộn 2 dãy trên thành dãy c sao cho dãy c vẫn có thứ tự tăng.\nXuất dãy a,b,c ra màn hình.\n\n(*) Cho mảng c có n phần tử (n&lt;200), các phần tử là các chữ số trong hệ đếm cơ số 16 (Hexa). Hãy tách mảng c ra các mảng con theo điều kiện sau: các mảng con được giới hạn bởi hai lần xuất hiện thứ hai của con số trong dãy. Ví dụ: 123A4518B23 có các dãy con là 123A451, 23A4518B2, 23A4518B23\n(**) Cho hai số nguyên dương A,B. Hãy xác định hai số C,D tạo thành từ hai số A,B sao cho C là số lớn nhất, D là số nhỏ nhất. Khi gạch đi một số chữ số trong C (D), thì các số còn lại giữ nguyên tạo thành A, các chữ số bỏ đi giữ nguyên tạo thành B. Ví dụ: A = 52568, B = 462384 thì C = 54625682384, D = 45256236884.\nViết chương trình nhập vào dãy số a gồm n số nguyên (n\\leq100).\n\nHãy đảo ngược dãy đó. Ví dụ: Nhập a: 3 4 5 2 0 4 1 thì dãy sau khi đảo: 1 4 0 2 5 4 3\n(*) Hãy kiểm tra xem dãy đã cho có thứ tự chưa (dãy được gọi là thứ tự khi là dãy tăng hoặc dãy giảm).\n\nCho mảng a có n phần tử hãy cho biết mảng này có đối xứng hay không.\n(**) Hãy viết chương trình phát sinh ngẫu nhiên mảng các số nguyên gồm 10000 phần tử, mỗi phần tử có giá trị từ 0 đến 32000 và xây dựng hàm thống kê số lần xuất hiện các phần tử trong mảng, sau đó cho biết phần tử nào xuất hiện nhiều lần nhất. Ví dụ: mảng: 5 6 11 4 4 5 4 thì 5 xuat hien 2 lan, 6 xuat hien 1 lan, 11 xuat hien 1 lan, 4 xuat hien 3 lan và 4 xuat hien nhieu lan nhat\nCho mảng a có n phần tử. Nhập vào số nguyên dương k, dịch phải xoay vòng mảng a k lần. Ví dụ: mảng a: 5 7 2 3 1 9 và k = 2 thì dịch phải xoay vòng mảng a: 1 9 5 7 2 3",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5-cpp.html#tóm-tắt",
    "href": "chapter-5-cpp.html#tóm-tắt",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "5.3 TÓM TẮT",
    "text": "5.3 TÓM TẮT\nDữ liệu kiểu mảng dùng cho việc biểu diễn những thông tin có cùng kiểu dữ liệu liên tiếp nhau. Khi cài đặt bài tập mảng một chiều nên xây dựng thành những hàm chuẩn để dùng lại cho các bài tập khác. Các thao tác trên mảng đều theo quy tắc nhất định, chúng ta có thể ứng dụng mảng trong việc biểu diễn số lớn, dùng bảng tra, khử đệ qui,.v.v",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-6-cpp.html",
    "href": "chapter-6-cpp.html",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "",
    "text": "6.1 LÝ THUYẾT\nTrong C++, chuỗi ký tự được thể hiện qua lớp std::string tiện lợi và an toàn. Chương này mô tả cách sử dụng std::string và các kỹ thuật xử lý chuỗi hiện đại trong C++.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6-cpp.html#lý-thuyết",
    "href": "chapter-6-cpp.html#lý-thuyết",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "",
    "text": "Chuỗi ký tự trong C++\n\nTrong C++ hiện đại, chuỗi ký tự được quản lý bởi lớp std::string trong thư viện &lt;string&gt;.\nstd::string tự động quản lý bộ nhớ và kích thước, giúp tránh các lỗi phổ biến như tràn bộ đệm và quên ký tự kết thúc \\0 của chuỗi kiểu C.\n\n\n\nKhai báo biến chuỗi\n\n#include &lt;string&gt;\n\nstd::string ⟨Tên chuỗi⟩;\nstd::string ⟨Tên chuỗi⟩ = \"Giá trị khởi tạo\";\n\n\nKhai báo 1 chuỗi ký tự chuoi và khởi tạo giá trị.\n#include &lt;string&gt;\n\nstd::string chuoi = \"Xin chao C++\";\nstd::string ten_sach; // Khai báo một chuỗi rỗng\n\n\n\nHàm nhập chuỗi\nSử dụng đối tượng cin và hàm getline từ thư viện &lt;iostream&gt; và &lt;string&gt;.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::cin &gt;&gt; chuoi; // Chỉ nhập đến khi gặp khoảng trắng\nstd::getline(std::cin, chuoi); // Nhập cả dòng, bao gồm khoảng trắng\n\nNhận các ký tự nhập từ bàn phím cho đến khi nhấn phím ENTER và đưa vào chuỗi s.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() \n{ \n    std::string s; \n    std::cout &lt;&lt; \"Nhap vao chuoi: \"; \n    std::getline(std::cin, s); \n    std::cout &lt;&lt; \"Chuoi vua nhap la: \" &lt;&lt; s &lt;&lt; std::endl;\n    return 0;\n}\n\n\n\nHàm xuất chuỗi\nSử dụng đối tượng cout từ thư viện &lt;iostream&gt;.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::cout &lt;&lt; chuoi;\n\nXuất chuỗi ra màn hình.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() \n{ \n    std::string chuoi = \"Vi du xuat chuoi\\n\"; \n    std::cout &lt;&lt; chuoi; \n    return 0;\n}\n\n\n\nCác hàm và toán tử phổ biến với std::string\n\n\n\n\n\n\n\n\nThao tác\nCú pháp C++\nChức năng\n\n\n\n\nLấy chiều dài\nstr.length() hoặc str.size()\nTrả về chiều dài của chuỗi.\n\n\nSao chép\ndest = src;\nGán giá trị của chuỗi src cho dest.\n\n\nNối chuỗi\ns1 += s2; hoặc s1.append(s2);\nNối chuỗi s2 vào sau chuỗi s1.\n\n\nSo sánh\ns1 == s2, s1 != s2, s1 &lt; s2\nSo sánh hai chuỗi theo thứ tự từ điển.\n\n\nTruy cập ký tự\nstr[i]\nTruy cập ký tự tại vị trí i.\n\n\nTìm chuỗi con\nstr.find(sub_str)\nTìm vị trí xuất hiện đầu tiên của sub_str trong str.\n\n\nLấy chuỗi con\nstr.substr(pos, len)\nLấy một chuỗi con từ vị trí pos với độ dài len.\n\n\nRỗng hay không\nstr.empty()\nKiểm tra xem chuỗi có rỗng không.\n\n\n\n\nNhập vào một chuỗi ký tự, xuất ra màn hình chuỗi bị đảo ngược thứ tự các ký tự. Ví dụ, nhập vào: Le Hoang Thai và xuất ra màn hình: iahT gnaoH eL\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt; // Để dùng std::reverse\n\n// Hàm đảo ngược chuỗi, trả về một chuỗi mới\nstd::string DaoChuoi(const std::string& s1) \n{ \n    std::string s2 = s1; // Sao chép chuỗi ban đầu\n    std::reverse(s2.begin(), s2.end()); // Dùng thuật toán đảo ngược\n    return s2;\n}\n\nint main() \n{\n    std::string s1, s2; \n    std::cout &lt;&lt; \"Nhap vao chuoi ky tu: \"; \n    std::getline(std::cin, s1); \n    \n    s2 = DaoChuoi(s1); \n    \n    std::cout &lt;&lt; \"Ket qua sau khi dao nguoc chuoi: \" &lt;&lt; s2 &lt;&lt; std::endl;\n    return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6-cpp.html#bài-tập",
    "href": "chapter-6-cpp.html#bài-tập",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "6.2 BÀI TẬP",
    "text": "6.2 BÀI TẬP\n\nBài tập cơ bản\n\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt; // Thư viện để \"token hóa\" chuỗi\n\nint main() {\n    std::string s = \"Truong DHKHTN TPHCM\";\n    std::stringstream ss(s);\n    std::string word;\n\n    while (ss &gt;&gt; word) {\n        std::cout &lt;&lt; word &lt;&lt; std::endl;\n    }\n    return 0;\n}\nCho biết kết quả của đoạn chương trình sau:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string s1 = \"Truong DHKHTN\";\n    std::string s2 = \" Tp. HCM\";\n    std::string vowels = \"aeiouAEIOU\";\n\n    std::string s = s1; // Gán s = s1\n    s += s2; // Nối s2 vào s\n\n    int n = s.length();\n    int k = 0;\n\n    std::cout &lt;&lt; \"Chuoi: \" &lt;&lt; s &lt;&lt; std::endl;\n\n    for (int i = 0; i &lt; n; i++) {\n        if (vowels.find(s[i]) != std::string::npos) {\n            k++;\n        }\n    }\n\n    std::cout &lt;&lt; \"Ket qua: \" &lt;&lt; k &lt;&lt; std::endl;\n    return 0;\n}\nViết chương trình nhập vào một chuỗi ký tự, đếm số ký tự có trong chuỗi.\nViết chương trình đếm có bao nhiêu khoảng trắng trong chuỗi.\nViết chương trình nhập vào một chuỗi, hãy loại bỏ những khoảng trắng thừa trong chuỗi.\nViết chương trình nhập vào hai chuỗi s_{1} và s_{2}, nối chuỗi s_{2} vào s_{1}. Xuất chuỗi s_{1} ra màn hình.\nĐổi tất cả các ký tự có trong chuỗi thành chữ thường.\nĐổi tất cả các ký tự trong chuỗi sang chữ in hoa.\nViết chương trình đổi những ký tự đầu tiên của mỗi từ thành chữ in hoa.\nViết chương trình đổi chữ xen kẽ 1 chữ hoa và 1 chữ thường. Ví dụ: nhập ABCDEfgh đổi thành AbCdEfGh.\nViết chương trình đảo ngược các ký tự trong chuỗi. Ví dụ: nhập ABCDE, xuất ra màn hình là EDCBA.\nViết chương trình tìm kiếm 1 ký tự xem có trong chuỗi hay không, nếu có xuất ra vị trí của từ đó.\nViết 1 chương trình đếm một ký tự xuất hiện bao nhiêu lần trong chuỗi.\nViết chương trình tìm kiếm tên trong chuỗi họ tên. Nếu có thì xuất ra là tên này đã nhập đúng, ngược lại thông báo là đã nhập sai.\nViết chương trình đảo vị trí của từ đầu và từ cuối. Ví dụ: nhập bo an co xuất ra co an bo.\nViết hàm cắt chuỗi họ tên thành chuỗi họ lót và chuỗi tên. Ví dụ: chuỗi họ tên là: Le Hoang Thai cắt ra 2 chuỗi là chuỗi họ lót Le Hoang và chuỗi tên là Thai.\nNhập một chuỗi bất kỳ, sau đó hỏi người dùng cần tách bắt đầu từ đâu trong chuỗi trở về sau. Ví dụ: Nhập chuỗi TRUONG DAI HOC KHOA HOC TU NHIEN. Người nhập muốn tách bắt đầu từ chữ KHOA thì sẽ xuất ra chuỗi KHOA HOC TU NHIEN ra màn hình.\nViết hàm kiểm tra xem chuỗi có đối xứng hay không?\nViết hàm tra xem trong chuỗi có ký tự số hay không nếu có tách ra thành một mảng số riêng.\nNhập một chuỗi bất kì, yêu cầu nhập 1 ký tự muốn xóa. Thực hiện xóa tất cả những ký tự đó trong chuỗi.\nViết chương trình tìm kiếm xem ký tự nào xuất hiện nhiều nhất trong chuỗi.\nViết 1 chương trình xoá một từ nào đó trong chuỗi. Ví dụ: Chuỗi ban đầu KHOA CONG NGHE THONG TIN và từ THONG, và kết quả xuất ra: KHOA CONG NGHE TIN.\n\n\n\nBài tập luyện tập và nâng cao\n\nĐổi các từ ở đầu câu sang chữ hoa và những từ không phải đầu câu sang chữ thường. Ví dụ: nGuYen vAN a đổi thành: Nguyen Van A.\n(*) Viết chương trình đảo ngược thứ tự các từ có trong chuỗi Ví dụ: Nhập Truong DHKHTN TpHCM Xuất ra màn hình là: TpHCM DHKHTN Truong.\nNhập 1 chuỗi bất kì, liệt kê xem mỗi ký tự xuất hiện mấy lần.\nViết hàm kiểm tra xem trong 2 chuỗi có bao nhiêu ký tự giống nhau.\nViết chương trình chữ chạy từ trái qua phải màn hình.\nViết 1 chương trình chèn 1 từ ở bất cứ vị trí nào mà người dùng yêu cầu.\n(*) Viết chương trình nhập vào một chuỗi đếm xem chuỗi có bao nhiêu từ. Các từ cách nhau bằng khoảng trắng, dấu chấm câu: dấu chấm (.), dấu phẩy (,), dấu chấm phẩy (;), dấu hỏi (?) và dấu chấm than (!).\n(**) Viết chương trình hiển thị một chuỗi ký tự. Chương trình cho phép di chuyển dấu nháy sang trái, sang phải, lên dòng hay xuống dòng bằng phím mũi tên, chèn hay xoá ký tự tại vị trí dấu nháy.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6-cpp.html#tóm-tắt",
    "href": "chapter-6-cpp.html#tóm-tắt",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "6.3 TÓM TẮT",
    "text": "6.3 TÓM TẮT\nTrong C++, nên ưu tiên sử dụng lớp std::string từ thư viện &lt;string&gt; để thao tác với chuỗi ký tự. std::string cung cấp cách tiếp cận an toàn, linh hoạt và mạnh mẽ hơn nhiều so với chuỗi ký tự kiểu C (mảng char). Nó tự động quản lý bộ nhớ, giúp tránh các lỗi phổ biến và cung cấp một tập hợp phong phú các hàm thành viên để xử lý chuỗi một cách hiệu quả.\nKhi nhập liệu, hãy sử dụng std::getline(std::cin, chuoi) để đọc cả một dòng văn bản có chứa khoảng trắng. Điều này an toàn và dễ đoán hơn so với việc dùng cin &gt;&gt; chuoi có thể gây ra các hành vi không mong muốn khi xử lý input phức tạp. Việc tận dụng các phương thức có sẵn như .length(), .find(), .substr() và các toán tử (+, ==, &lt;) sẽ giúp mã nguồn của bạn ngắn gọn, dễ đọc và ít lỗi hơn.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-7-cpp.html",
    "href": "chapter-7-cpp.html",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "",
    "text": "7.1 LÝ THUYẾT\nĐây là kiểu dữ liệu dùng để biểu diễn dữ liệu kiểu bảng, kiểu dữ liệu này rất thích hợp cho các bài toán liên quan đến ma trận, đồ thị hoặc ảnh và video số.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7-cpp.html#lý-thuyết",
    "href": "chapter-7-cpp.html#lý-thuyết",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "",
    "text": "Mảng hai chiều là tập hợp các phần tử được tổ chức theo dòng và cột\n\n\nKhai báo biến mảng\n\n⟨Kiểu dữ liệu phần tử⟩ ⟨Tên mảng⟩[⟨Số dòng⟩][⟨Số cột⟩]; \n\n\nKhai báo mảng hai chiều A và b\nint A[20][10];\nfloat b[10][10]; \n\n\n\nTruy xuất phần tử của mảng\n\n⟨tên mảng⟩[⟨chỉ số dòng⟩][⟨chỉ số cột⟩]\n\n\n\nKhai báo kiểu mảng\n\ntypedef ⟨Kiểu dữ liệu phần tử⟩ ⟨Tên kiểu mảng⟩[⟨Số dòng⟩][⟨Số cột⟩];\n\n\nKhai báo kiểu mảng hai chiều MANG2D chứa các số nguyên int có tối đa 100 dòng và 100 cột\n#define MAX 100\ntypedef int MANG2D[MAX][MAX];",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7-cpp.html#bài-tập",
    "href": "chapter-7-cpp.html#bài-tập",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "7.2 BÀI TẬP",
    "text": "7.2 BÀI TẬP\n\nBài tập cơ bản\n\n\nKỹ thuật nhập/xuất mảng hai chiều\n\nNhập và xuất mảng hai chiều\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\n#define MAX 100\ntypedef int MANG2D[MAX][MAX];\n\nvoid Nhap(MANG2D a, int &d, int &c) \n{ \n    std::cout &lt;&lt; \"\\nNhap so dong: \"; \n    std::cin &gt;&gt; d; \n    std::cout &lt;&lt; \"Nhap so cot: \"; \n    std::cin &gt;&gt; c; \n    for(int i = 0; i &lt; d; i++) \n    {\n        for(int j = 0; j &lt; c; j++) \n        { \n            std::cout &lt;&lt; \"a[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"] = \"; \n            std::cin &gt;&gt; a[i][j]; \n        }\n    }\n}\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\n#define MAX 100\ntypedef int MANG2D[MAX][MAX];\n\nvoid Xuat(MANG2D a, int d, int c) \n{ \n    std::cout &lt;&lt; \"\\nNoi dung ma tran:\\n\"; \n    for(int i = 0; i &lt; d; i++) \n    { \n        for(int j = 0; j &lt; c; j++)  \n            std::cout &lt;&lt; std::setw(8) &lt;&lt; a[i][j]; \n        std::cout &lt;&lt; \"\\n\"; \n    } \n} \n\n\nViết hàm nhập ma trận các số nguyên dương (nhập sai báo lỗi và không cho nhập).\nViết hàm nhập/xuất ma trận các số thực.\nViết hàm in ra những phần tử có ký số tận cùng là 5.\nViết chương trình khởi tạo giá trị các phần tử là ngẫu nhiên cho ma trận các số nguyên kích thước m\\times n.\nViết hàm tạo ma trận a các số nguyên gồm 9 dòng 14 cột. Trong đó phần tử a[i][j]=i*j.\nViết hàm in tam giác Pascal với chiều cao h. Ví dụ: h = 5\n1 \n1 1 \n1 2 1 \n1 3 3 1 \n1 4 6 4 1 \n\n\n\nKỹ thuật đặt cờ hiệu\n\nViết hàm kiểm tra xem trong ma trận các số nguyên có tồn tại các số nguyên lẻ lớn hơn 100 không?\n// Giả sử MANG2D đã được định nghĩa\nint KiemTraLe(MANG2D a, int d, int c) \n{ \n    int flag = 0; // tra ve 1 neu co, nguoc lai tra ve 0\n    for(int i = 0; i &lt; d; i++) \n    {\n        for(int j = 0; j &lt; c; j++) \n        {\n            if(a[i][j] % 2 != 0 && a[i][j] &gt; 100) \n            { \n                flag = 1; \n                break; // Thoát khỏi vòng lặp trong\n            }\n        }\n        if (flag == 1)\n        {\n            break; // Thoát khỏi vòng lặp ngoài\n        }\n    }\n    return flag; \n}\n\n\n\nKỹ thuật đặt lính canh\n\nViết hàm tìm phần tử nhỏ nhất trong ma trận.\n// Giả sử MANG2D đã được định nghĩa\nint TimMin(MANG2D a, int d, int c) \n{ \n    int min = a[0][0]; \n    for(int i = 0; i &lt; d; i++)\n    {\n        for(int j = 0; j &lt; c; j++) \n        {\n            if(a[i][j] &lt; min) \n            {\n                min = a[i][j];\n            }\n        }\n    }\n    return min; \n} \n\n\n\nKỹ thuật tính tổng\n\nViết hàm tính tổng các phần tử trong ma trận.\n// Giả sử MANG2D đã được định nghĩa\nint TinhTong(MANG2D a, int d, int c) \n{ \n    int tong = 0;\n    for(int i = 0; i &lt; d; i++) \n    {\n        for(int j = 0; j &lt; c; j++) \n        {\n            tong += a[i][j];\n        }\n    }\n    return tong; \n}\n\n\nViết hàm tính tổng các phần tử trên cùng một dòng.\nViết hàm tính tổng các phần tử trên cùng một cột.\nViết hàm tính tổng các phần tử chẵn có trong ma trận.\nViết hàm tính tổng các phần tử là số nguyên tố có trong ma trận.\nViết hàm tính tổng các số hoàn thiện trong ma trận các số nguyên.\nViết hàm tính tổng các giá trị lớn nhất trên mỗi dòng.\nViết hàm tính giá trị trung bình của các phần tử nhỏ nhất trên mỗi cột.\n\n\n\nKỹ thuật tìm kiếm\n\nViết hàm tìm vị trí phần tử lớn nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử nhỏ nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử chẵn cuối cùng trong ma trận các số nguyên.\nViết hàm tìm phần tử âm lẻ lớn nhất trong ma trận.\nViết hàm tìm phần tử chẵn dương và nhỏ nhất trong ma trận.\nViết hàm tìm số hoàn thiện đầu tiên trong ma trận các số nguyên.\nViết hàm tìm số hoàn thiện lớn nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử nguyên tố cuối cùng trong ma trận các số nguyên.\nViết hàm tìm trong 2 ma trận các số nguyên, những phần tử giống nhau.\nViết hàm tìm và liệt kê những phần tử cực đại trong ma trận (một phần tử được coi là cực đại khi nó lớn hơn các phần tử xung quanh nó).\nViết hàm tìm dòng có tổng lớn nhất trong ma trận các số thực.\nViết hàm tìm cột có tổng nhỏ nhất trong ma trận các số nguyên.\n\n\n\nKỹ thuật đếm\n\nViết hàm đếm các phần tử chẵn trong ma trận.\n// Giả sử MANG2D đã được định nghĩa\nint DemChan(MANG2D a, int d, int c) \n{ \n    int dem = 0; \n    for(int i = 0; i &lt; d; i++) \n    {\n        for(int j = 0; j &lt; c; j++) \n        {\n            if(a[i][j] % 2 == 0) \n            {\n                dem++;\n            }\n        }\n    }\n    return dem; \n}\n\n\nViết hàm đếm các giá trị âm, dương trong ma trận các số thực.\nViết hàm đếm các giá trị chẵn, lẻ trong ma trận các số nguyên.\nViết hàm đếm số lần xuất hiện của phần tử x trong ma trận các số thực.\nViết hàm đếm các giá trị nhỏ hơn x trong ma trận các số thực.\nViết hàm đếm các phần tử nguyên tố trong ma trận các số nguyên.\nViết hàm đếm các giá trị cực đại trong ma trận các số nguyên.\nViết hàm đếm các giá trị cực tiểu trong ma trận các số nguyên.\nViết hàm đếm các cực trị trong ma trận các số nguyên (một phần tử được coi là cực trị khi nó là giá trị cực đại hay cực tiểu).\nViết hàm đếm các giá trị là số hoàn thiện trong ma trận các số nguyên.\n\n\n\nKỹ thuật sắp xếp\n\nViết hàm sắp xếp ma trận tăng dần từ trên xuống dưới và từ trái sang phải không dùng mảng phụ.\n#include &lt;utility&gt; // cho std::swap\n\n// Giả sử MANG2D đã được định nghĩa\nvoid SapTang(MANG2D a, int d, int c) \n{ \n    int n = d * c;\n    for(int i = 0; i &lt; n - 1; i++) \n    {\n        for(int j = i + 1; j &lt; n; j++) \n        {\n            if(a[i/c][i%c] &gt; a[j/c][j%c]) \n            { \n                std::swap(a[i/c][i%c], a[j/c][j%c]);\n            }\n        }\n    }\n}\n\n\nViết hàm sắp xếp ma trận theo thứ tự tăng dần từ trên xuống dưới và từ trái qua phải theo phương pháp dùng mảng phụ.\nHướng dẫn: Đổ ma trận sang mảng một chiều, sắp xếp trên mảng một chiều theo thứ tự tăng dần, sau đó chuyển ngược mảng một chiều thành ma trận kết quả.\nViết hàm sắp xếp ma trận theo thứ tự giảm dần từ trên xuống dưới và từ trái sang phải.\nViết hàm sắp xếp các dòng trên ma trận theo thứ tự tăng dần.\nViết hàm sắp xếp các cột trên ma trận theo thứ tự giàm dần.\nViết hàm sắp xếp ma trận theo đường zig zag ngang. Ví dụ:\n\\begin{array}{ccc}\n5 & 6 & 3\\\\\n1 & 8 & 7\\\\\n2 & 4 & 9\n\\end{array} \\to \\begin{array}{ccc}\n1 & 2 & 3\\\\\n6 & 5 & 4\\\\\n7 & 8 & 9\n\\end{array}\nViết hàm sắp xếp ma trận theo đường zig zag chéo. Ví du:\n\\begin{array}{cccc}\n1 & 2 & 6 & 7\\\\\n3 & 5 & 8 & 13\\\\\n4 & 9 & 12 & 14\\\\\n10 & 11 & 15 & 16\n\\end{array}\nViết hàm sắp xếp ma trận theo đường xoắn ốc từ ngoài vào trong theo chiều kim đồng hồ. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n12 & 13 & 14 & 5\\\\\n11 & 16 & 15 & 6\\\\\n10 & 9 & 8 & 7\n\\end{array}\n\n\n\nKỹ thuật thêm - xoá - thay thế\n\nViết hàm xoá một dòng i trên ma trận.\nViết hàm xoá một cột j trên ma trận.\nViết hàm xoá dòng có tổng lớn nhất trên ma trận.\nViết hàm hoán vị dòng có tổng lớn nhất với dòng có tổng nhỏ nhất.\nViết hàm tìm và thay thế các phần tử chẵn trong ma trận bằng ước số nhỏ nhất của nó.\nViết hàm thay thế những phần tử có giá trị x thành phần tử có giá trị y trong ma trận (x,y nhập từ bàn phím).\n\n\n\nMảng vuông và các kỹ thuật xử lý\n\nMảng vuông là mảng hai chiều có số dòng và số cột bằng nhau.\n\n\nCho một mảng vuông\n\nĐường chéo chính (loại 1): chỉ số dòng = chỉ số cột\nĐường chéo song song với đường chéo chính (loại 1): chỉ số dòng - chỉ số cột = hằng số\nĐường chéo phụ (loại 2): chỉ số dòng + chỉ số cột = số dòng (hoặc số cột) - 1\nĐường chéo song song với đường chéo phụ (loại 2): chỉ số dòng + chỉ số cột = hằng số\n\n\n\nCho mảng vuông A, in ra các phần tử nằm trên đường chéo song song với đường chéo chính và xuất phát từ (i_0,j_0).\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\n// Giả sử A, n, i0, j0 đã được khai báo và khởi tạo giá trị\nfor(int i = i0, j = j0; i &lt; n && j &lt; n; i++, j++) {\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; A[i][j];\n}\n\n\nCho mảng vuông A, in ra các phần tử nằm trên đường chéo song song với đường chéo phụ và xuất phát từ (i_0,j_0).\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\n// Giả sử A, n, i0, j0 đã được khai báo và khởi tạo giá trị\nfor(int i = i0, j = j0; i &lt; n && j &gt;= 0; i++, j--) {\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; A[i][j];\n}\n\n\nViết chương trình in ra các phần tử nằm trên 2 đường chéo chính và phụ.\nViết hàm in ra các phần tử nằm phía trên đường chéo phụ của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía dưới đường chéo phụ của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía dưới đường chéo chính của ma trận vuông các số nguyên.\nViết hàm tìm phần tử lớn nhất nằm trên đường chéo chính của ma trận vuông.\nViết hàm in các số nguyên tố nằm trên đường chéo phụ của ma trận vuông.\nViết hàm tìm phần tử nhỏ nhất trên mỗi đường chéo loại 2 của ma trận.\nViết hàm tính tổng các phần tử nằm trên đường chéo chính của ma trận vuông.\nViết hàm tìm đường chéo có tổng lớn nhất trong các đường chéo loại 1.\nViết hàm tính tổng các giá trị nhỏ nhất nằm trên từng đường chéo loại 2.\nViết hàm đến các phần tử nguyên tố trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm đếm các giá trị chẵn trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm đếm các giá trị là bội của 3 và 5 trên đường chéo chính của ma trận các số nguyên.\nViết hàm đếm các giá trị nguyên tố trên 2 đường chéo (chính, phụ) của ma trận vuông các số nguyên.\nCho ma trận vuông, viết hàm sắp xếp tăng dần các phần tử nằm trên các đường chéo song song với đường chéo chính.\nViết chương trình nhập một ma trận vuông các số nguyên, và thực hiện những công việc sau:\n\nSắp xếp các phần tử nằm trên các đường chéo loại 1 tăng dần\nSắp xếp các phần tử nằm trên các đường chéo loại 2 giảm dần.\nSắp xếp với điều kiện: các phần tử trên đường chéo chính tăng, các phần tử trên các đường chéo song song với đường chéo chính giảm.\n\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình tính tổng, tích của hai ma trận các số nguyên.\nViết hàm kiểm tra xem ma trận vuông các số nguyên có đối xứng qua đường chéo chính hay không.\nViết hàm kiểm tra xem trong ma trận vuông cấp n có hàng nào trùng nhau hay không, nếu có thì chỉ rõ những hàng nào. (trùng giá trị và vị trí).\nViết chương trình nhập vào ma trận vuông kích thước n\\times n. Hãy viết hàm thực hiện những công việc sau:\n\nIn ra các phần tử trên 4 đường biên của ma trận.\nTính tổng các phần tử trên biên.\n\n(*) Viết chương trình xoay ma trận các số thực 90^{o} ngược chiều kim đồng hồ. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 12\\\\\n13 & 14 & 15 & 16\n\\end{array} \\to \\begin{array}{cccc}\n4 & 8 & 12 & 16\\\\\n3 & 7 & 11 & 15\\\\\n2 & 6 & 10 & 14\\\\\n1 & 5 & 9 & 13\n\\end{array}\nViết chương trình dịch phải xoay vòng một cột trong ma trận các số thực.\nViết chương trình dịch xuống xoay vòng một dòng trong ma trận các số thực.\n(*) Cho ma trận A_{m\\times n} các số nguyên hãy phát sinh ma trận B sao cho B là ma trận lật ngược của ma trận A. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 12\\\\\n13 & 14 & 15 & 16\n\\end{array} \\to \\begin{array}{cccc}\n4 & 3 & 2 & 1\\\\\n8 & 7 & 6 & 5\\\\\n12 & 11 & 10 & 9\\\\\n16 & 15 & 14 & 13\n\\end{array}\n(**) Cho ma trận A_{m\\times n} hãy phát sinh ma trận B sao cho phần tử B(i,j) là trung bình cộng của các phần tử trong hình vuông 3\\times3 tâm tại (i,j). Ví dụ\n\\begin{array}{cccc}\n1 & 5 & 2 & 6\\\\\n4 & 2 & 3 & 6\\\\\n8 & 7 & 9 & 1\\\\\n10 & 2 & 12 & 13\n\\end{array} \\to \\begin{array}{cccc}\n3 & 2 & 4 & 4\\\\\n4 & 4 & 4 & 4\\\\\n5 & 6 & 6 & 7\\\\\n6 & 8 & 7 & 8\n\\end{array}\n(**) Cho ma trận các số nguyên dương A_{m\\times n}. Hãy xây dựng ma trận B_{m\\times n}. Sao cho phần tử B(i,j) là số lớn nhất trong ô vuông 3\\times3 tâm tại (i,j) của A. Ví dụ:\n\\begin{array}{cccc}\n1 & 5 & 2 & 6\\\\\n4 & 2 & 3 & 6\\\\\n8 & 7 & 9 & 1\\\\\n10 & 2 & 12 & 13\n\\end{array} \\to \\begin{array}{cccc}\n5 & 5 & 6 & 6\\\\\n8 & 9 & 9 & 9\\\\\n10 & 12 & 13 & 13\\\\\n10 & 12 & 13 & 13\n\\end{array}\n(**) Cho ma trận A_{m\\times n}. Hãy xây dựng ma trận B_{m\\times n} với phần tử B(i,j) được xác định theo qui tắc sau: tại vị trí (i,j) trên mảng A kẻ hai tia vuông góc với nhau, tạo thành với trục hoành một góc 45^{o} từ trên xuống dưới; B(i,j) là tổng của tất cả các số của vùng mặt phẳng tạo bởi hai tia này và các cạnh của bảng. Ví dụ:\n\\begin{array}{ccc}\n1 & 3 & 2\\\\\n6 & 4 & 3\\\\\n2 & 5 & 7\n\\end{array} \\to \\begin{array}{ccc}\n25 & 30 & 23\\\\\n13 & 18 & 15\\\\\n2 & 5 & 7\n\\end{array}\n(**) Cho ma trận vuông A_{m\\times n}. Hãy xây dựng mảng B_{m\\times n} bằng cách: phần tử B(i,j) là số lớn nhất trong tam giác vuông vẽ từ A(i,j) tới đường chéo chính. Ví dụ:\n\\begin{array}{ccc}\n1 & 3 & 2\\\\\n6 & 4 & 3\\\\\n2 & 5 & 7\n\\end{array} \\to \\begin{array}{ccc}\n1 & 4 & 7\\\\\n6 & 4 & 7\\\\\n7 & 7 & 7\n\\end{array}\n(*) Viết chương trình hiển thị đồng hồ điện tử (gồm giờ phút), với giờ lấy từ hệ thống và đồng hồ được cập nhật theo phút.\nHướng dẫn: Tạo 1 ma trận giá trị gồm 0 hoặc 1, vị trí nào cần hiển thị thì gán giá trị là 1, ngược lại có giá trị là 0. Sau mỗi phút cập nhật lại ma trận và hiển thị lên màn hình. Ví dụ: 01 giờ 25 phút\n  1111   11    11111111 11111111\n11    11 11 11       11 11 \n11    11 11    11111111 11111111\n11    11 11 11 11             11 \n  1111   11    11111111 11111111\nNhập vào mảng hai chiều gồm n dòng và m cột các số nguyên. Hãy tìm phần tử lớn nhất trên mỗi dòng và đồng thời nhỏ nhất trên mỗi cột, hoặc lớn nhất trên mỗi cột và đồng thời nhỏ nhất trên mỗi dòng. Có bao nhiêu phần tử như thế? Ví dụ:\n\n\n\n3\n6\n2\n1\n\n\n4\n7\n6\n9\n\n\n5\n15\n8\n7\n\n\n\nViết chương trình tạo ngẫu nhiên một ma trận các số nguyên trong khoảng \\left[0,...,50\\right], tìm những phần tử cực đại (là phần tử lớn hơn các phần tử xung quanh). Ví dụ:\n\n\n\n2\n6\n8\n4\n\n\n9\n7\n5\n3\n\n\n6\n2\n8\n1\n\n\n\n(**) Cho ma trận các số nguyên A_{m\\times n} (m,n\\geq3). Hãy tìm ma trận con (3\\times3) có tổng lớn nhất. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 11\\\\\n13 & 14 & 15 & 16\n\\end{array} \\to \\begin{array}{ccc}\n6 & 7 & 8\\\\\n10 & 11 & 11\\\\\n14 & 15 & 16\n\\end{array}\nNhập ma trận vuông cấp n\\times n (n&lt;10). In ra các phần tử của ma trận này theo hướng của đừơng chéo chính:\n(**) Hãy điền các số từ 1 đến n^{2} vào ma trận cấp n (n&gt;2), chỉ xét trường hợp n là số lẻ với tính chất P là tổng các số bằng nhau.\nHướng dẫn: Ma phương của một bảng vuông cấp n, trong mỗi ô nhận một giá trị sao cho, mỗi hàng, mỗi cột và mỗi đường chéo đều thoả mãn một tính chất P nào đó cho trước. Ví dụ:\n\\begin{array}{ccc}\n2 & 7 & 6\\\\\n9 & 5 & 1\\\\\n4 & 3 & 8\n\\end{array}\n(*) Viết hàm in ma trận các số nguyên dương theo qui luật được mô tả như sau: các phần tử phía trên đường chéo phụ là giá trị bình phương, các giá trị từ đường chéo phụ trở xuống là các số nguyên tố. Ví dụ:\n\\begin{array}{ccccc}\n1 & 9 & 36 & 100 & 31\\\\\n4 & 25 & 81 & 37 & 17\\\\\n16 & 64 & 41 & 19 & 7\\\\\n49 & 43 & 23 & 11 & 3\\\\\n47 & 29 & 13 & 5 & 2\n\\end{array}\nCho ma trận vuông a cấp n (n lẻ và 3\\leq n\\leq15), mỗi phần tử đều có giá trị nguyên dương. Hãy xây dựng hàm kiểm tra xem ma trận a có phải là ma phương hay không?\n(**) Viết chương trình giải bài toán 8 hậu. Hãy đặt 8 con hậu trên bàn cờ 8\\times8 sao cho chúng không ăn nhau (2 hậu ăn nhau khi cùng hàng, cùng cột và cùng nằm trên đường chéo).\nHướng dẫn: Dùng ma trận 8\\times8 để lưu bàn cờ. Mỗi ô có 3 trạng thái:\n\nCó hậu: 1\nÔ trống: 0\nÔ không được đi: -1\n\n(**) Viết chương trình giải bài toán mã đi tuần. Hãy đi con mã 64 lượt đi trên bàn cờ 8\\times8 sao cho mỗi ô chỉ đi qua một lần (xuất phát từ một ô bất kỳ).\nHướng dẫn: Đứng tại một ô trên bàn cờ con mã có thể đi được 1 trong 8 hướng sau. Khai báo 8 hướng đi của mã như sau:\nstruct DIEM \n{ \n    int x, y; \n}; \n\nDIEM huongdi[8] = {{-2, -1}, {-2, 1}, {-1, 2}, {1, 2},\n                   {2, 1}, {2, -1}, {1, -2}, {-1, -2}};\nTrong đó mỗi thành phần của huongdi là độ lệch của dòng và cột so với vị trí của con mã. Ví dụ: huongdi[0] có độ lệch 2 dòng và 1 cột. (Giá trị âm biểu thị độ lệch về bên trái cột hay hướng lên của dòng). Chọn vị trí đi kế tiếp sao cho vị trí đó phải gần với biên hay góc nhất (tức số đường đi có thể đi là ít nhất).\nViết chương trình giải bài toán 8-puzzle. Cho ma trận vuông 3\\times3 gồm các số nguyên từ 0 đến 8 trong đó 0 là ô trống. Bài toán đặt ra là hãy đưa ma trận ở một trạng thái đầu về trạng thái đích, mỗi lần chỉ dịch chuyển được 1 ô. Ví dụ:\nTrạng thái đầu\n\n\n\n2\n1\n0\n\n\n3\n8\n7\n\n\n6\n4\n5\n\n\n\n\\toTrạng thái đích\n\n\n\n1\n2\n3\n\n\n4\n5\n6\n\n\n7\n8\n0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7-cpp.html#tóm-tắt",
    "href": "chapter-7-cpp.html#tóm-tắt",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "7.3 TÓM TẮT",
    "text": "7.3 TÓM TẮT\nKiểu dữ liệu mảng hai chiều được ứng dụng rộng rãi trong các bài toán về tìm đường đi trong đồ thị, xử lý ảnh, xử lý những dữ liệu dạng bảng.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-8-cpp.html",
    "href": "chapter-8-cpp.html",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "",
    "text": "8.1 LÝ THUYẾT\nCung cấp cơ chế cho phép khai báo các kiểu dữ liệu mới để giải quyết theo yêu cầu của bài toán dựa vào những kiểu dữ liệu cơ bản được cài đặt sẵn trong ngôn ngữ lập trình.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8-cpp.html#lý-thuyết",
    "href": "chapter-8-cpp.html#lý-thuyết",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "",
    "text": "Kiểu dữ liệu cấu trúc (struct) là gom nhóm các phần tử có thể không cùng kiểu dữ liệu.\n\n\nKhái báo kiểu dữ liệu cấu trúc\nTrong C++, ta có thể khai báo một struct một cách đơn giản.\n\nstruct ⟨Tên cấu trúc⟩ {\n    ⟨Các dữ liệu thành phần⟩\n};\n\nViệc sử dụng typedef như trong C vẫn được hỗ trợ nhưng không còn cần thiết cho việc khai báo biến cấu trúc.\n\n// Cách làm cũ hơn, vẫn hợp lệ trong C++\ntypedef struct {\n    ⟨Các dữ liệu thành phần⟩\n} ⟨Tên kiểu dữ liệu cấu trúc⟩;\n\n\nKiểu dữ liệu về ngày DATE gồm các thành phần:\n\nThứ (thu): chuỗi ký tự.\nNgày (ngay): số nguyên không dấu 1 byte.\nTháng (thang): số nguyên không dấu 1 byte.\nNăm (nam): số nguyên 2 bytes.\n\nTa định nghĩa cấu trúc DATE\n#include &lt;string&gt;\n\nstruct DATE {\n    std::string thu;\n    unsigned char ngay;\n    unsigned char thang;\n    short nam;\n};\n\n\n\nKhai báo biến cấu trúc\nKhi ta định nghĩa kiểu dữ liệu tức là ta có một kiểu dữ liệu mới, muốn sử dụng ta phải khai báo biến. Cú pháp khai báo kiểu dữ liệu cũng giống như cách khai báo của các kiểu dữ liệu chuẩn.\n\n⟨Tên cấu trúc⟩ ⟨tên biến⟩;\n\n\nKhai báo biến x có kiểu cấu trúc DATE\nDATE x;\n\nLưu ý các thành phần của một cấu trúc cũng có thể là kiểu dữ liệu cấu trúc.\n\nĐịnh nghĩa kiểu dữ liệu của học sinh HOCSINH gồm:\n\nMã số học sinh (MSHS): chuỗi ký tự.\nHọ tên (hoten): chuỗi ký tự.\nNgày tháng năm sinh (ngaysinh): kiểu DATE.\nĐịa chỉ (diachi): chuỗi ký tự.\nGiới tính (phai): chuỗi ký tự.\nĐiểm trung bình (diemtb): số thực.\n\nTa định nghĩa kiểu HOCSINH như sau:\n#include &lt;string&gt;\n\n// Giả định struct DATE đã được định nghĩa ở trên\nstruct HOCSINH {\n    std::string MSHS;\n    std::string hoten;\n    DATE ngaysinh;\n    std::string diachi;\n    std::string phai;\n    float diemtb;\n};\n\n\n\nTruy xuất thành phần\n\n⟨Tên biến cấu trúc⟩.⟨Tên thành phần⟩\n\n\nTruy xuất thành phần ngay của biến x\nDATE x; // khai báo biến x kiểu DATE\nx.ngay = 5; // gán ngay bằng 5\n\n\nViết chương trình nhập vào toạ độ hai điểm trong mặt phẳng và tính tổng hai toạ độ này.\n#include &lt;iostream&gt;\n\n// Khai báo một kiểu dữ liệu DIEM gồm tọa độ x và y\nstruct DIEM {\n    int x;\n    int y;\n};\n\nvoid Nhap(DIEM &d) {\n    std::cout &lt;&lt; \"\\nNhap vao toa do diem\\n\";\n    std::cout &lt;&lt; \"Hoanh do: \";\n    std::cin &gt;&gt; d.x;\n    std::cout &lt;&lt; \"Tung do: \";\n    std::cin &gt;&gt; d.y;\n}\n\nvoid Xuat(DIEM d) {\n    std::cout &lt;&lt; \"\\nToa do diem: (\" &lt;&lt; d.x &lt;&lt; \", \" &lt;&lt; d.y &lt;&lt; \")\";\n}\n\nDIEM Tong(DIEM d1, DIEM d2) {\n    DIEM temp;\n    temp.x = d1.x + d2.x;\n    temp.y = d1.y + d2.y;\n    return temp;\n}\n\nint main() {\n    DIEM A, B, AB; // khai bao 3 diem A, B, AB\n    Nhap(A);\n    Xuat(A);\n    Nhap(B);\n    Xuat(B);\n    std::cout &lt;&lt; \"\\nTong cua hai diem vua nhap la: \";\n    AB = Tong(A, B);\n    Xuat(AB);\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n\n\n\nMảng cấu trúc\n\nCách khai báo tương tự như mảng một chiều hay ma trận. Trong C++ hiện đại, nên sử dụng std::vector để thay thế cho mảng C-style.\nCách truy cập phần tử trong mảng cũng như truy cập trên mảng một chiều hay ma trận. Nhưng do từng phần tử có kiểu cấu trúc nên phải chỉ định rõ cần lấy thành phần nào, tức là phải truy cập đến thành phần cuối cùng có kiểu là dữ liệu cơ bản (xem lại bảng các kiểu dữ liệu cơ bản).\n\n\n\nKỹ thuật viết chương trình có mảng cấu trúc\nDo kiểu dữ liệu có cấu trúc thường chứa rất nhiều thành phần nên khi viết chương trình loại này ta cần lưu ý:\n\nXây dựng hàm xử lý cho một kiểu cấu trúc.\nMuốn xử lý cho mảng cấu trúc, ta gọi lại hàm xử lý cho một kiểu cấu trúc đã được xây dựng bằng cách dùng vòng lặp.\n\n\nCho một lớp học gồm n học sinh. Thông tin của một học sinh được mô tả trong ví dụ trước. Hãy viết chương trình nhập và xuất danh sách học sinh sau đó đếm xem có bao nhiêu học sinh được lên lớp (Điều kiện được lên lớp là điểm trung bình \\geq5.0). Cách làm:\n\nTrước hết ta phải xây dựng hàm nhập và xuất cho 1 học sinh.\nXây dựng hàm nhập và xuất ngày tháng năm (Kiểu dữ liệu DATE).\nSau đó mới xây dựng hàm nhập và xuất cho danh sách học sinh.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt; // Để sử dụng numeric_limits\n\nstruct DATE {\n    unsigned char ngay;\n    unsigned char thang;\n    int nam;\n};\n\nstruct HOCSINH {\n    std::string MSHS;\n    std::string hoten;\n    DATE ngaysinh;\n    std::string diachi;\n    std::string phai;\n    float diemtb;\n};\n\nvoid NhapNamSinh(DATE &d);\nvoid XuatNamSinh(DATE d);\nvoid Nhap1HS(HOCSINH &hs);\nvoid Xuat1HS(HOCSINH hs);\nvoid NhapDSHS(std::vector&lt;HOCSINH&gt; &lh, int &n);\nvoid XuatDSHS(const std::vector&lt;HOCSINH&gt; &lh, int n);\nint DemHSLenLop(const std::vector&lt;HOCSINH&gt; &lh, int n);\n\nint main() {\n    std::vector&lt;HOCSINH&gt; lh; // Sử dụng vector để quản lý danh sách\n    int n, sohsdau;\n    NhapDSHS(lh, n);\n    XuatDSHS(lh, n);\n    sohsdau = DemHSLenLop(lh, n);\n    std::cout &lt;&lt; \"\\nSo luong hoc sinh duoc len lop la: \" &lt;&lt; sohsdau &lt;&lt; std::endl;\n    return 0;\n}\n\nvoid NhapNamSinh(DATE &d) {\n    std::cout &lt;&lt; \"Nhap vao ngay: \";\n    std::cin &gt;&gt; d.ngay;\n    std::cout &lt;&lt; \"Nhap vao thang: \";\n    std::cin &gt;&gt; d.thang;\n    std::cout &lt;&lt; \"Nhap vao nam: \";\n    std::cin &gt;&gt; d.nam;\n}\n\nvoid XuatNamSinh(DATE d) {\n    // std::cout &lt;&lt; d.ngay &lt;&lt; \" / \" &lt;&lt; d.thang &lt;&lt; \" / \" &lt;&lt; d.nam;\n    printf(\"%02u / %02u / %4d\", d.ngay, d.thang, d.nam); // printf dễ định dạng hơn\n}\n\nvoid Nhap1HS(HOCSINH &hs) {\n    // Xóa bộ đệm đầu vào trước khi đọc chuỗi\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Nhap ma so hoc sinh: \";\n    getline(std::cin, hs.MSHS);\n\n    std::cout &lt;&lt; \"Nhap ho ten hoc sinh: \";\n    getline(std::cin, hs.hoten);\n\n    std::cout &lt;&lt; \"Nhap ngay thang nam sinh:\\n\";\n    NhapNamSinh(hs.ngaysinh);\n    \n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Nhap vao dia chi: \";\n    getline(std::cin, hs.diachi);\n\n    std::cout &lt;&lt; \"Phai: \";\n    getline(std::cin, hs.phai);\n\n    std::cout &lt;&lt; \"Nhap vao diem trung binh: \";\n    std::cin &gt;&gt; hs.diemtb;\n}\n\nvoid NhapDSHS(std::vector&lt;HOCSINH&gt; &lh, int &n) {\n    std::cout &lt;&lt; \"Nhap vao so luong hoc sinh: \";\n    std::cin &gt;&gt; n;\n    lh.resize(n); // Thay đổi kích thước vector\n    for (int i = 0; i &lt; n; i++) {\n        std::cout &lt;&lt; \"\\nNhap vao thong tin cua hoc sinh thu \" &lt;&lt; i + 1 &lt;&lt; \":\\n\";\n        Nhap1HS(lh[i]); // Gọi hàm nhập thông tin 1 học sinh\n    }\n}\n\nvoid Xuat1HS(HOCSINH hs) {\n    std::cout &lt;&lt; \"\\nMa so hoc sinh: \" &lt;&lt; hs.MSHS;\n    std::cout &lt;&lt; \"\\nHo ten hoc sinh: \" &lt;&lt; hs.hoten;\n    std::cout &lt;&lt; \"\\nNgay thang nam sinh: \";\n    XuatNamSinh(hs.ngaysinh);\n    std::cout &lt;&lt; \"\\nDia chi: \" &lt;&lt; hs.diachi;\n    std::cout &lt;&lt; \"\\nPhai: \" &lt;&lt; hs.phai;\n    printf(\"\\nDiem trung binh: %.2f\", hs.diemtb);\n}\n\nvoid XuatDSHS(const std::vector&lt;HOCSINH&gt; &lh, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        std::cout &lt;&lt; \"\\n\\nThong tin hoc sinh thu \" &lt;&lt; i + 1 &lt;&lt; \":\";\n        Xuat1HS(lh[i]); // Gọi hàm xuất thông tin 1 học sinh\n    }\n}\n\nint DemHSLenLop(const std::vector&lt;HOCSINH&gt; &lh, int n) {\n    int d = 0;\n    for (int i = 0; i &lt; n; i++)\n        if (lh[i].diemtb &gt;= 5.0)\n            d++;\n    return d;\n}\n\n\nCho một mảng các phân số (PHANSO). Hãy viết chương trình nhập và xuất danh sách các phân số sau đó tìm phân số có giá trị lớn nhất, tổng và tích các phân số và nghịch đảo giá trị các phân số trong mảng. Cách làm:\n\nTrước hết ta phải xây dựng hàm nhập và xuất cho 1 phân số.\nXây dựng hàm tính tổng, hiệu, tích, thương, rút gọn, so sánh và nghịch đảo cho 2 phân số.\nSau đó mới xây dựng hàm nhập, xuất, tính tổng, tích cho mảng các phân số.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt; // For std::gcd in C++17\n#include &lt;cmath&gt;   // For abs\n\n// Hàm tìm UCLN, có thể dùng std::gcd từ C++17\nint USCLN(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (a != b) {\n        if (a &gt; b) a = a - b;\n        else b = b - a;\n    }\n    return a;\n}\n\nstruct PHANSO {\n    int tu, mau;\n};\n\nPHANSO RutGon(PHANSO ps) {\n    if (ps.tu == 0) {\n        ps.mau = 1;\n        return ps;\n    }\n    int us = USCLN(ps.tu, ps.mau);\n    ps.tu /= us;\n    ps.mau /= us;\n    if (ps.mau &lt; 0) { // Đưa dấu trừ lên tử\n        ps.tu = -ps.tu;\n        ps.mau = -ps.mau;\n    }\n    return ps;\n}\n\nvoid NhapPS(PHANSO &ps) {\n    do {\n        std::cout &lt;&lt; \"Nhap tu so: \";\n        std::cin &gt;&gt; ps.tu;\n        std::cout &lt;&lt; \"Nhap mau so: \";\n        std::cin &gt;&gt; ps.mau;\n        if (ps.mau == 0)\n            std::cout &lt;&lt; \"\\nMau so khong duoc bang 0, nhap lai phan so\\n\";\n        else\n            break;\n    } while (true);\n    ps = RutGon(ps);\n}\n\nvoid XuatPS(PHANSO ps) {\n    if (ps.mau == 1 || ps.tu == 0) {\n        std::cout &lt;&lt; ps.tu;\n    } else {\n        std::cout &lt;&lt; ps.tu &lt;&lt; \"/\" &lt;&lt; ps.mau;\n    }\n}\n\nvoid NhapMangPS(std::vector&lt;PHANSO&gt; &dsps) {\n    int n;\n    std::cout &lt;&lt; \"\\nNhap so luong phan so: \";\n    std::cin &gt;&gt; n;\n    dsps.resize(n);\n    for (int i = 0; i &lt; n; i++) {\n        std::cout &lt;&lt; \"\\nNhap vao phan so thu \" &lt;&lt; i + 1 &lt;&lt; \":\\n\";\n        NhapPS(dsps[i]);\n    }\n}\n\nvoid XuatMangPS(const std::vector&lt;PHANSO&gt; &dsps) {\n    for (const auto &ps : dsps) {\n        XuatPS(ps);\n        std::cout &lt;&lt; \"\\t\";\n    }\n}\n\nPHANSO NghichDao(PHANSO ps) {\n    PHANSO kq;\n    kq.tu = ps.mau;\n    kq.mau = ps.tu;\n    return kq;\n}\n\nPHANSO Nhan(PHANSO ps1, PHANSO ps2) {\n    PHANSO kq;\n    kq.tu = ps1.tu * ps2.tu;\n    kq.mau = ps1.mau * ps2.mau;\n    return RutGon(kq);\n}\n\nPHANSO Cong(PHANSO ps1, PHANSO ps2) {\n    PHANSO kq;\n    kq.tu = ps1.tu * ps2.mau + ps1.mau * ps2.tu;\n    kq.mau = ps1.mau * ps2.mau;\n    return RutGon(kq);\n}\n\n// Trả về 1 nếu ps1 &gt; ps2, -1 nếu ps1 &lt; ps2, 0 nếu bằng nhau\nint SoSanh(PHANSO ps1, PHANSO ps2) {\n    double val1 = static_cast&lt;double&gt;(ps1.tu) / ps1.mau;\n    double val2 = static_cast&lt;double&gt;(ps2.tu) / ps2.mau;\n    if (val1 &gt; val2) return 1;\n    if (val1 &lt; val2) return -1;\n    return 0;\n}\n\nPHANSO TimMax(const std::vector&lt;PHANSO&gt; &dsps) {\n    PHANSO max = dsps[0];\n    for (size_t i = 1; i &lt; dsps.size(); i++) {\n        if (SoSanh(dsps[i], max) == 1) {\n            max = dsps[i];\n        }\n    }\n    return max;\n}\n\nPHANSO TongCacPS(const std::vector&lt;PHANSO&gt; &dsps) {\n    PHANSO s = {0, 1};\n    for (const auto &ps : dsps) {\n        s = Cong(s, ps);\n    }\n    return s;\n}\n\nPHANSO TichCacPS(const std::vector&lt;PHANSO&gt; &dsps) {\n    PHANSO p = {1, 1};\n    for (const auto &ps : dsps) {\n        p = Nhan(p, ps);\n    }\n    return p;\n}\n\nvoid NghichDaoCacPS(std::vector&lt;PHANSO&gt; &dsps) {\n    for (auto &ps : dsps) {\n        ps = NghichDao(ps);\n    }\n}\n\nint main() {\n    std::vector&lt;PHANSO&gt; a;\n    NhapMangPS(a);\n    \n    std::cout &lt;&lt; \"\\nMang cac phan so vua nhap: \";\n    XuatMangPS(a);\n    \n    PHANSO max = TimMax(a);\n    std::cout &lt;&lt; \"\\nPhan so co gia tri lon nhat: \";\n    XuatPS(max);\n    \n    PHANSO s = TongCacPS(a);\n    std::cout &lt;&lt; \"\\nTong gia tri cac phan so co trong mang: \";\n    XuatPS(s);\n    \n    PHANSO p = TichCacPS(a);\n    std::cout &lt;&lt; \"\\nTich gia tri cac phan so co trong mang: \";\n    XuatPS(p);\n    \n    NghichDaoCacPS(a);\n    std::cout &lt;&lt; \"\\nMang phan so sau khi nghich dao cac phan tu: \";\n    XuatMangPS(a);\n    \n    std::cout &lt;&lt; std::endl;\n    return 0;\n}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8-cpp.html#bài-tập",
    "href": "chapter-8-cpp.html#bài-tập",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "8.2 BÀI TẬP",
    "text": "8.2 BÀI TẬP\n\nBài tập cơ bản\n\nViết chương trình sử dụng con trỏ cấu trúc để hiển thị giờ, phút, giây ra màn hình, và tính khoảng cách giữa 2 mốc thời gian.\nViết chương trình sử dụng con trỏ cấu trúc thể hiện ngày, tháng, năm ra màn hình, và tính khoảng cách giữa 2 ngày.\nViết chương trình khai báo kiểu dữ liệu thể hiện một số phức. Sử dụng kiểu này để viết hàm tính tổng, hiệu, tích của hai số phức.\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một phân số. Hãy viết hàm thực hiện những công việc sau:\n\nTính tổng, hiệu, tích, thương hai phân số.\nRút gọn phân số.\nQui đồng hai phân số.\nSo sánh hai phân số.\n\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một hỗn số. Hãy viết hàm thực hiện những công việc sau:\n\nĐổi hỗn số sang phân số\nTính tổng, tích hai hỗn số\n\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một điểm trong hệ tọa độ 0xy. Hãy viết hàm thực hiện các công việc sau:\n\nTìm những điểm đối xứng của nó qua tung độ, hoành độ, toạ độ tâm.\nHãy tính tổng, hiệu, tích của hai điểm trong mặt phẳng toạ độ 0xy.\nTính khoảng cách giữa hai điểm.\n\nCho một hình trụ có các thông tin sau: BanKinh (bán kính hình trụ kiểu số thực), ChieuCao (chiều cao hình trụ kiểu số thực). Hãy thực hiện các công việc sau.\n\nNhập dữ liệu cho hình trụ trên.\nTính diện tích xung quanh, diện tích toàn phần, thể tích hình trụ.\n\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình tạo một mảng các số phức. Hãy viết hàm tính tổng, tích các số phức có trong mảng.\nViết chương trình tạo một mảng các phân số. Hãy viết hàm thực hiện các công việc sau:\n\nTính tổng tất cả các phân số (kết quả dưới dạng phân số tối giản)\nTìm phân số lớn nhất, phân số nhỏ nhất.\nSắp xếp mảng tăng dần.\n\nViết chương trình khai báo kiểu dữ liệu STACK (cơ chế LIFO). Viết hàm làm những công việc sau:\n\nKiểm tra STACK rỗng\nKiểm tra STACK đầy\nThêm phần tử vào STACK\nLấy phần tử ra khỏi STACK\n\nTổ chức dữ liệu để quản lí sinh viên bằng cấu trúc mẫu tin trong một mảng N phần tử, mỗi phần tử có cấu trúc như sau:\n\nMã sinh viên.\nTên.\nNăm sinh.\nĐiểm toán, lý, hoá, điểm trung bình. Viết chương trình thực hiện những công việc sau: \n\n\nNhập danh sách các sinh viên cho một lớp học.\nXuất danh sách sinh viên ra màn hình.\nTìm sinh viên có điểm trung bình cao nhất.\nSắp xếp danh sách lớp theo thứ tự tăng dần của điểm trung bình.\nSắp xếp danh sách lớp theo thứ tự giảm dần của điểm toán.\nTìm kiếm và in ra các sinh viên có điểm trung bình lớn hơn 5 và không có môn nào dưới 3.\nTìm sinh viên có tuổi lớn nhất.\nNhập vào tên của một sinh viên. Tìm và in ra các thông tin liên quan đến sinh viên đó (nếu có).\n\nTổ chức dữ liệu quản lí danh mục các bộ phim VIDEO, các thông tin liên quan đến bộ phim này như sau:\n\nTên phim (tựa phim).\nThể loại (3 loại: hình sự, tình cảm, hài).\nTên đạo diễn.\nTên điễn viên nam chính.\nTên diễn viên nữ chính.\nNăm sản xuất.\nHãng sản xuất Viết chương trình thực hiện những công việc sau: \n\n\nNhập vào bộ phim mới cùng với các thông tin liên quan đến bộ phim này.\nNhập một thể loại: In ra danh sách các bộ phim thuộc thể loại này.\nNhập một tên nam diễn viên. In ra các bộ phim có diễn viên này đóng.\nNhập tên đạo diễn. In ra danh sách các bộ phim do đạo diễn này dàn dựng.\n\nMột thư viện cần quản lý thông tin về các đầu sách. Mỗi đầu sách bao gồm các thông tin sau: MaSSach (mã số sách), TenSach (tên sách), TacGia (tác giả), SL (số lượng các cuốn sách của đầu sách). Viết chương trình thực hiện các chức năng sau:\n\nNhập vào một danh sách các đầu sách (tối đa là 100 đầu sách)\nNhập vào tên của quyển sách. In ra thông tin đầy đủ về các sách có tên đó, nếu không có thì tên của quyển sách đó thì báo là: Không Tìm Thấy.\nTính tổng số sách có trong thư viện.\n\nViết chương trình tạo một mảng danh sách các máy tính của một cửa hàng, thông tin của một máy tính bao gồm:\n\nLoại máy\nNơi sản xuất\nThời gian bảo hành \n\n\nViết hàm nhập một dãy các loại máy tính có thông tin như trên.\nHãy viết hàm thống kê xem có bao nhiêu máy có thời gian bảo hành là 1 năm.\nIn ra danh sách các máy tính có xuất xứ từ Mỹ.\n\nĐể lắp ráp một máy vi tính hoàn chỉnh cần phải có tối thiểu 10 linh kiện loại A và có thể lắp bổ sung thêm vào khoảng tối đa 8 linh kiện loại B. Tại một cửa hàng vi tính cần quản lý bán hàng các loại linh kiện tại cửa hàng. Thông tin về một loại linh kiện gồm có: Tên linh kiện, quy cách, loại, đơn giá loại 1 (chất lượng tốt - số nguyên), đơn giá loại 2 (chất lượng thường - số nguyên). Viết chương trình thực hiện những công việc sau:\n\nNhập vào thông tin về các linh kiện có ở cửa hàng.\nXuất danh sách các linh kiện đã nhập theo thứ tự tăng dần của loại linh kiện và tên linh kiện.\nCho biết đã có đủ 10 linh kiện loại A cần thiết lắp ráp máy hay chưa?\n\nMột cửa hàng cần quản lý các mặt hàng, thông tin một mặt hàng bao gồm:\n\nMã hàng.\nTên mặt hàng.\nSố lượng.\nĐơn giá.\nSố lượng tồn.\nThời gian bảo hành (tính theo đơn vị tháng). \n\n\nHãy nhập vào một danh sách các mặt hàng.\nTìm mặt hàng có số lượng tồn nhiều nhất.\nTìm mặt hàng có số lượng tồn ít nhất.\nTìm mặt hàng có giá tiền cao nhất.\nIn ra những mặt hàng có thời gian bảo hành lớn hơn 12 tháng.\nSắp xếp các mặt hàng theo thứ tự tăng dần của số lượng tồn.\n\nViết chương trình quản lý hồ sơ nhân viên trong một công ty, chương trình thực hiện những công việc sau:\n\nHọ và tên.\nPhái.\nNgày sinh.\nĐịa chỉ.\nLương cơ bản.\nBảo hiểm xã hội.\nThưởng.\nPhạt.\nLương thực lĩnh = Lương cơ bản + Thưởng - Bảo hiểm xã hội - Phạt. \n\n\nNhập vào hồ sơ của các nhân viên trong công ty.\nXuất danh sách các nhân viên theo lương thực lĩnh giảm dần bằng 2 cách sau:\n\nCấp phát vùng nhớ tĩnh.\nCấp phát vùng nhớ động.\n\n\n(*) Viết chương trình quản lý lớp học của một trường. Các thông tin của một lớp học như sau:\n\nTên lớp.\nSĩ số.\nDanh sách các sinh viên trong lớp. \n\n\nNhập vào danh sach các lớp với thông tin yêu cầu như trên.\nIn danh sách các lớp có trên 5 sinh viên có điểm trung bình loại giỏi.\nTìm lớp có nhiều sinh viên nhất.\nTìm lớp có ít sinh viên nhất.\nTìm sinh viên có điểm trung bình cao nhất.\nTìm lớp có số lượng sinh viên đạt điểm trung bình loại giỏi nhiều nhất.\n\nViết chương trình quản lý vé tàu, thông tin một vé tàu như sau:\n\nNgày giờ khởi hành, ngày giờ đến.\nGa đi, ga đến.\nLoại tàu, loại chỗ ngồi (ngồi, nằm, cứng, mềm).\nSố toa, số ghế. \n\n\nViết hàm nhập vào danh sách các vé tàu.\nIn danh sách các vé tàu có ga đến là Huế.\nIn danh sách các vé tàu có ga đến là Hà Nội và đi ngày 8/6/2005.\nĐếm xem có bao nhiêu khách đi tàu loại chỗ ngồi là nằm cứng.\n\nViết chương trình tính tiền điện hàng tháng của các hộ gia đình, thông tin các khách hàng như sau:\n\nKỳ thu, từ ngày… đến ngày…\nTên khách hàng, mã khách hàng.\nĐịa chỉ.\nĐiện năng tiêu thụ (Kwh). \n\n\nNhập vào danh sách các khách hàng.\nXuất danh sách hoá đơn theo thứ tự tăng dần của điện năng tiêu thụ.\nTính tiền điện của các khách hàng theo quy định sau.\n\n100 kw đầu tiên là 550 đ / kw - 50 kw tiếp theo là 900 đ / kw\n50 kw tiếp theo là 1210 đ / kw\nThuế 10% trên tổng số tiền phải trả\n\nTính tổng số tiền thu được của các khách hàng.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8-cpp.html#tóm-tắt",
    "href": "chapter-8-cpp.html#tóm-tắt",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "8.3 TÓM TẮT",
    "text": "8.3 TÓM TẮT\nKiểu dữ liệu có cấu trúc cho phép ta định nghĩa những kiểu dữ liệu bất kỳ trên cơ sở là những kiểu dữ liệu cơ bản có sẵn trong ngôn ngữ lập trình. Khi xây dựng xong kiểu dữ liệu mới ta phải định nghĩa những thao tác cho kiểu dữ liệu đó. Những kiểu dữ liệu tự định nghĩa này thông thường có rất nhiều thành phần, mỗi thành phần cũng có thể là một kiểu dữ liệu tự định nghĩa, vấn đề là ta chọn kiểu dữ liệu cơ bản nào để xây dựng nên chúng sao cho phù hợp về mặt kiểu dữ liệu và phù hợp về kích thước lưu trữ (vừa đủ). Cách sử dụng những kiểu dữ liệu tự định nghĩa cũng giống như các kiểu dữ liệu cơ bản. Muốn sử dụng phải khai báo biến, khi truy cập các thành phần phải truy cập theo quy ước. Khi làm việc với mảng các kiểu dữ liệu có cấu trúc, ta nên xử lý cho từng thành phần cấu trúc rồi mới xử lý cho mảng cấu trúc bằng cách dùng vòng lặp. Việc sử dụng std::vector và std::string trong C++ giúp quản lý bộ nhớ và chuỗi ký tự an toàn và hiệu quả hơn.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-9-cpp.html",
    "href": "chapter-9-cpp.html",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "",
    "text": "9.1 LÝ THUYẾT\nChương này sẽ trình bày cấu trúc tập tin, cài đặt các thao tác, một số hàm thư viện và ứng dụng trong việc tổ chức dữ liệu trên tập tin.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9-cpp.html#lý-thuyết",
    "href": "chapter-9-cpp.html#lý-thuyết",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "",
    "text": "Khái niệm\nTrong các chương trình trước thì các dữ liệu đưa vào chương trình chỉ được tồn tại trong RAM, khi thoát chương trình thì tất cả dữ liệu đều bị mất. Để khắc phục tình trạng này C++ cung cấp cho ta các lớp thư viện &lt;fstream&gt; để lưu trữ và truy xuất tập tin. Và ở đây ta chỉ đề cập đến 2 loại tập tin:\n\nTập tin văn bản: là tập tin lưu trữ dưới dạng ký tự.\nTập tin nhị phân: là tập tin dùng lưu trữ dưới dạng nhị phân.\n\n\n\nThao tác với tập tin\nQuá trình thao tác trên tập tin thông qua 4 bước:\n\nKhai báo đối tượng luồng tập tin (file stream object).\nMở tập tin.\nXử lý tập tin.\nĐóng tập tin.\n\n\nKhai báo\nĐể làm việc với tập tin trong C++, chúng ta sử dụng các lớp từ thư viện &lt;fstream&gt;: ifstream (đọc), ofstream (ghi), fstream (đọc và ghi).\n\n#include &lt;fstream&gt;\n\n// Khai báo\nstd::fstream ⟨tên biến⟩;\nstd::ifstream ⟨tên biến⟩;\nstd::ofstream ⟨tên biến⟩;\n\n\nKhai báo biến luồng tập tin f\n#include &lt;fstream&gt;\n\nstd::fstream f;\n\n\n\nMở tập tin\n\n⟨tên biến⟩.open(⟨đường dẫn tên tập tin⟩, ⟨cờ truy nhập⟩);\nCác cờ truy nhập tập tin thông dụng:\n\nstd::ios::in: mở ra để đọc (r).\nstd::ios::out: mở ra để ghi (w).\nstd::ios::app: mở ra để thêm vào (a).\nstd::ios::binary: chế độ nhị phân (b).\nstd::ios::ate: di chuyển con trỏ tới cuối file khi mở.\n\nCác cờ có thể được kết hợp với nhau bằng toán tử |. Ví dụ: std::ios::in | std::ios::out tương đương với r+.\n\n\nMở tập tin văn bản tên DATA.TXT để đọc\n#include &lt;fstream&gt;\n\n// Khai báo biến luồng f\nstd::ifstream f;\n\n// Mở tập tin văn bản để đọc\nf.open(\"C:\\\\DATA.TXT\"); \n\n// Hoặc có thể khai báo và mở cùng lúc\nstd::ifstream f_another(\"C:\\\\DATA.TXT\");\n\n\n\nĐọc tập tin nhị phân\n⟨tên biến⟩.read(reinterpret_cast&lt;char*&gt;(&ptr), sizeof(ptr));\n\n\nGhi tập tin nhị phân\n⟨tên biến⟩.write(reinterpret_cast&lt;const char*&gt;(&ptr), sizeof(ptr));\n\n\nĐóng tập tin\nSau khi không còn làm việc với tập tin, để đảm bảo an toàn cho dữ liệu thì nhất thiết ta phải đóng tập tin lại. Trong C++, các đối tượng luồng sẽ tự động đóng khi ra khỏi phạm vi, nhưng việc đóng tập tin một cách tường minh là một thói quen tốt.\n\nĐóng một tập tin\n⟨tên biến⟩.close();\n\n\nĐóng tập tin f và tập tin g\nf.close();\ng.close();\n\n\n\nXoá tập tin\nSử dụng hàm remove từ thư viện &lt;cstdio&gt;.\n#include &lt;cstdio&gt;\n\nremove(⟨đường dẫn + tên tập tin⟩);\n\n\nĐổi tên tập tin\nSử dụng hàm rename từ thư viện &lt;cstdio&gt;.\n#include &lt;cstdio&gt;\n\nrename(⟨tên tập tin cũ⟩, ⟨tên tập tin mới⟩);\n\n\nDi chuyển con trỏ tập tin:\nSử dụng seekg (seek get - cho đọc) và seekp (seek put - cho ghi).\n⟨tên biến⟩.seekg(⟨độ dời⟩, ⟨mốc⟩);\nmốc:\n\nstd::ios::beg: dời đến đầu tập tin.\nstd::ios::cur: dời so với vị trí hiện hành.\nstd::ios::end: dời đến cuối tập tin.\n\n\nDi chuyển vị trí con trỏ đọc về sau 5 bytes, sau đó di chuyển về trước 4 bytes\nf.seekg(5, std::ios::cur);\nf.seekg(-4, std::ios::cur);\n\n\n\nCho biết vị trí con trỏ file\nSử dụng tellg (tell get - cho đọc) và tellp (tell put - cho ghi).\n⟨tên biến⟩.tellg();\n\n\n\nCác ví dụ minh hoạ\n\nKiểm tra một tập tin có thể mở được không?\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nvoid KiemTra(const std::string& tenfile)\n{\n    std::ifstream f(tenfile);\n    if (!f.is_open()) // hoặc if (!f)\n    {\n        std::cout &lt;&lt; \"Khong mo duoc tap tin \" &lt;&lt; tenfile;\n        return;\n    }\n    std::cout &lt;&lt; \"Tap tin \" &lt;&lt; tenfile &lt;&lt; \" da duoc mo\";\n    f.close();\n}\n\n\nTập tin văn bản\n\nViết chương trình phát sinh ngẫu nhiên ma trận a kích thước 5\\times6, lưu ma trận này vào file data.txt. Đọc lại file data.txt đưa dữ liệu vào ma trận b và xuất ra màn hình xem kết quả lưu đúng không? Cấu trúc của file data.txt như sau:\n\nDòng đầu lưu 2 số nguyên: m,n thể hiện số dòng và số cột của ma trận.\nm dòng tiếp theo, mỗi dòng gồm n phần tử là giá trị các phần tử trên một dòng của ma trận.\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nconst int MAX = 100;\n\nvoid LuuFile(const std::string& tenfile, int a[MAX][MAX], int m, int n)\n{\n    std::ofstream f(tenfile);\n    if (!f.is_open())\n    {\n        std::cout &lt;&lt; \"\\nKhong tao duoc file.\";\n        return;\n    }\n    f &lt;&lt; m &lt;&lt; \" \" &lt;&lt; n &lt;&lt; \"\\n\";\n    for (int i = 0; i &lt; m; i++)\n    {\n        for (int j = 0; j &lt; n; j++)\n            f &lt;&lt; a[i][j] &lt;&lt; \"\\t\";\n        f &lt;&lt; \"\\n\";\n    }\n    f.close();\n}\n\nvoid DocFile(const std::string& tenfile, int a[MAX][MAX], int& m, int& n)\n{\n    std::ifstream f(tenfile);\n    if (!f.is_open())\n    {\n        std::cout &lt;&lt; \"\\nKhong doc duoc file.\";\n        return;\n    }\n    f &gt;&gt; m &gt;&gt; n;\n    for (int i = 0; i &lt; m; i++)\n    {\n        for (int j = 0; j &lt; n; j++)\n            f &gt;&gt; a[i][j];\n    }\n    f.close();\n}\n\nint main()\n{\n    int i, j;\n    int a[MAX][MAX], m = 5, n = 6;\n    int b[MAX][MAX], x, y;\n\n    srand(time(0)); // Khởi tạo bộ sinh số ngẫu nhiên\n    for (i = 0; i &lt; m; i++)\n        for (j = 0; j &lt; n; j++)\n            a[i][j] = rand() % 1000;\n\n    LuuFile(\"data.txt\", a, m, n);\n    DocFile(\"data.txt\", b, x, y);\n\n    for (i = 0; i &lt; x; i++)\n    {\n        for (j = 0; j &lt; y; j++)\n            std::cout &lt;&lt; b[i][j] &lt;&lt; \"\\t\";\n        std::cout &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n\n\nViết chương trình tạo tập tin văn bản OUT.TXT gồm n số nguyên, các số của dãy được tạo ngẫu nhiên có giá trị tuyệt đối không vượt quá M (n,M đọc từ tập tin IN.TXT). Kết quả chương trình là 1 tập tin văn bản có dòng thứ nhất ghi số n; n dòng tiếp theo ghi các số tạo được, mỗi số trên một dòng.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nvoid NhapFile(const std::string& tenfile, int& n, int& M)\n{\n    std::ifstream fi(tenfile);\n    fi &gt;&gt; n &gt;&gt; M;\n    fi.close();\n}\n\nvoid XuatFile(const std::string& tenfile, int n, int M)\n{\n    std::ofstream fo(tenfile);\n    fo &lt;&lt; n &lt;&lt; \"\\n\";\n    for (int i = 0; i &lt; n; i++)\n    {\n        // Tạo số ngẫu nhiên trong khoảng [-M, M]\n        int randomNumber = rand() % (2 * M + 1) - M;\n        fo &lt;&lt; randomNumber &lt;&lt; \"\\n\";\n    }\n    fo.close();\n}\n\nint main()\n{\n    int n, M;\n    srand(time(0)); // Khởi tạo bộ sinh số ngẫu nhiên\n    NhapFile(\"IN.TXT\", n, M);\n    XuatFile(\"OUT.TXT\", n, M);\n    return 0;\n}\n\n\n\nTập tin nhị phân\n\nViết hàm đọc/ghi một danh sách sinh viên của một lớp vào tập tin\n// Giả sử cấu trúc SINHVIEN đã được định nghĩa\nstruct SINHVIEN {\n    // các trường dữ liệu của sinh viên\n};\n\nvoid Doc(const std::string& tenfile, SINHVIEN ds[], int& siso)\n{\n    std::ifstream fi(tenfile, std::ios::in | std::ios::binary);\n    if (!fi) return;\n\n    fi.seekg(0, std::ios::end);\n    siso = fi.tellg() / sizeof(SINHVIEN);\n    fi.seekg(0, std::ios::beg);\n    fi.read(reinterpret_cast&lt;char*&gt;(ds), siso * sizeof(SINHVIEN));\n    fi.close();\n}\n\nvoid Ghi(const std::string& tenfile, SINHVIEN ds[], int siso)\n{\n    std::ofstream fo(tenfile, std::ios::out | std::ios::binary);\n    if (!fo) return;\n\n    fo.write(reinterpret_cast&lt;const char*&gt;(ds), siso * sizeof(SINHVIEN));\n    fo.close();\n}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9-cpp.html#bài-tập",
    "href": "chapter-9-cpp.html#bài-tập",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "9.2 BÀI TẬP",
    "text": "9.2 BÀI TẬP\n\nBài tập cơ bản\n\nViết chương trình tạo tập tin văn bản chứa 1 dãy số nguyên bất kỳ.\nViết chương trình tạo tập tin nhị phân chứa 10000 số nguyên bất kỳ ghi vào file SONGUYEN.INP. Mỗi dòng 10 số, sau đó viết chương trình đọc file SONGUYEN.INP, sắp xếp theo thứ tự tăng dần và lưu kết quả vào file SONGUYEN.OUT.\nViết chương trình tạo một file chứa 10000 số nguyên ngẫu nhiên đôi một khác nhau trong phạm vi từ 1 đến 32767 và đặt tên là SONGUYEN.INP.\nViết chương trình tạo một file chứa các số nguyên có tên SONGUYEN.INP. Sau đó đọc file SONGUYEN.INP và ghi các số chẵn vào file SOCHAN.OUT và những số lẻ vào file SOLE.OUT.\nViết chương trình ghi vào tập tin SOCHAN.DAT các số nguyên chẵn từ 0 đến 100.\nViết chương trình đọc tập tin SOCHAN.DAT và xuất ra màn hình, mỗi dòng 30 số.\nViết chương trình giả lập lệnh COPY CON để tạo tập tin văn bản. Khi kết thúc tập tin nhấn phím F6 để lưu\nViết chương trình giả lập lệnh TYPE để in nội dung của tập tin văn bản ra màn hình.\nViết chương trình kiểm tra một tập tin nào đó có trong một thư mục được chỉ định hay không?\nViết chương trình giả lập lệnh DEL để xoá tập tin. Yêu cầu nhập đường dẫn và tên tập tin, kiểm tra sự tồn tại của tập tin, nếu có thì xoá tập tin được chỉ định.\nViết chương trình giả lập lệnh RENAME để đổi tên một tập tin.\nViết chương trình tạo file văn bản có tên là MATRIX.INP có cấu trúc như sau:\n\nDòng đầu ghi hai số m,n.\nTrong m dòng tiếp theo mỗi dòng ghi n số và các số các nhau một khoảng cách.\n\nHãy kiểm tra xem trong file đó có bao nhiêu số nguyên tố. Kết quả cần ghi vào file MATRIX.OUT có nội dung là một số nguyên đó là số lượng các số nguyên tố trong file MATRIX.INP.\nCho số nguyên n, hãy in tam giác PASCAL gồm n dòng\n\nDữ liệu vào: tập tin văn bản PAS.INP gồm 1 dòng chứa giá trị n.\nKết quả: đưa ra tập tin văn bản PAS.OUT thể hiện một tam giác PASCAL n dòng.\n\nCho mảng các số nguyên, hãy sắp xếp mảng theo thứ tự tăng dần.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm 2 dòng\n\nDòng 1 chứa số nguyên n (n\\leq100).\nDòng 2 chứa n số nguyên.\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm hai dòng\n\nDòng 1 chứa n phần tử của mảng các số nguyên.\nDòng 2 chứa n số nguyên được xếp tăng dần.\n\nCho mảng các số nguyên, tìm phần tử lớn nhất của mảng.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm hai dòng:\n\nDòng 1 chứa số nguyên n (n\\leq100).\nDòng 2 chứa n số nguyên.\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm 1 dòng ghi 2 giá trị x,y trong đó x là giá trị lớn nhất, y là vị trí của x trong mảng.\n\n\n\nBài tập luyện tập và nâng cao\n\nCho mảng các số nguyên, tính tổng các phần tử của mảng.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm hai dòng\n\nDòng 1 chứa số nguyên n (n\\leq10)\nDòng 2 chứa n số nguyên\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm một dòng ghi tổng các phần tử trong mảng.\nCho mảng các số nguyên, hãy liệt kê các phần tử là số nguyên tố\nDữ liệu vào: tập tin văn bản NT.INP gồm hai dòng\n\nDòng 1 chứa số nguyên n (n\\leq100)\nDòng 2 chứa n số nguyên\n\nKết quả: đưa ra tập tin văn bản NT.OUT gồm hai dòng:\n\nDòng 1 chứa số lượng các phần tử nguyên tố trong mảng.\nDòng 2 liệt kê các số nguyên tố đó.\n\n(*) Tạo file văn bản có tên là INPUT.TXT có cấu trúc như sau:\n\nDòng đầu tiên ghi N (N là số nguyên dương nhập từ bàn phím).\nTrong các dòng tiếp theo ghi N số nguyên ngẫu nhiên trong phạm vi từ 0 đến 100, mỗi dòng 10 số (các số cách nhau ít nhất một khoảng trắng).\n\nHãy đọc dữ liệu của file INPUT.TXT và lưu vào mảng một chiều A. Thực hiện các công việc sau:\n\nTìm giá trị lớn nhất của mảng A.\nĐếm số lượng số chẵn, số lượng số lẻ của mảng A.\nHãy sắp xếp các phần tử theo thứ tự tăng dầ n.\n\nHãy ghi các kết quả vào file văn bản có tên OUTPUT.TXT\n(*) Viết chương trình nhập và lưu hồ sơ của sinh viên vào một file có tên là DSSV.TXT. Sau đó đọc file DSSV.TXT và cất vào mảng, hãy sắp xếp các hồ sơ sinh viên theo thứ tự giảm dần theo điểm trung bình môn học rồi in ra màn hình hồ sơ các sinh viên theo thứ tự đó ra màn hình có thông tin như sau:\n\nMã số sinh viên.\nHọ và tên sinh viên.\nĐiểm trung bình kiểm tra.\nĐiểm thi hết môn.\nĐiểm trung bình môn học tính bằng (Điểm trung bình kiểm tra + điểm thi hết môn)/2.\n\n(*) Tạo một file text có tên là INPUT.TXT có cấu trúc như sau:\n\nDòng đầu tiên ghi hai số M và N (M,N là hai số nguyên dương nhập từ bàn phím).\nTrong M dòng tiếp theo mỗi dòng ghi N số nguyên ngẫu nhiên trong phạm vi từ 0 đến 100 (các số này cách nhau ít nhất một khoảng trắng).\n\nHãy đọc dữ liệu từ file trên và lưu vào mảng hai chiều. Rồi thực hiện các công việc sau:\n\nTìm giá trị lớn nhất của ma trận.\nĐếm số lượng số chẵn, lẽ, nguyên tố có trong ma trận.\nHãy tính tổng các phần tử trên mỗi dòng của ma trận.\n\nHãy ghi kết quả này vào file văn bản có tên là OUTPUT.TXT\n(**) Xét dãy số \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}. Một đoạn con của dãy là dãy các phần tử liên tiếp nhau được xác định bởi chỉ số của số bắt đầu (L) và chỉ số của số cuối cùng (R). Tổng các số trên đoạn được gọi là tổng đoạn. Yêu cầu: Cho dãy \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}, hãy tìm đoạn con có tổng đoạn lớn nhất (T).\nDữ liêu được cho trong tập tin văn bản SUMMAX.INP\n\nDòng thứ nhất chứ số nguyên N (0&lt;N\\leq30000)\nN dòng tiếp theo, mỗi dòng chứa một số là các số của dãy đã cho theo đúng thứ tự. Giá trị tuyệt đối của mội số không vượt quá 30000 Kết quả tìm được ghi vào tập tin văn bản SUMMAX.OUT\n\n(*) Cho dãy \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}, hãy tìm đoạn con tăng dần có tổng lớn nhất.\nDữ liệu: được cho trong tập tin AMAX.INP\n\nDòng 1 chứa số nguyên N (0&lt;N\\leq30000).\nN dòng tiếp theo, mỗi dòng chứa một số là các số của dãy đãy cho theo đúng thứ tự. Giá trị tuyệt đối của mỗi số không vược quá 30000.\n\nKết quả tìm được ghi vàp tin văn bản AMAX.OUT gồm hai dòng:\n\nDòng 1 ghi tổng của dãy con.\nDòng 2 ghi mảng con tăng dần có tổng lớn nhất.\n\nViết chương trình nhập lý lịch một nhân viên vào danh sách các nhân viên. Khi không nhập nữa bấm phím ESC và ghi vào tập tin NHANVIEN.DAT sau đó:\n\nĐọc từ tập tin NHANVIEN.DAT vừa tạo và in danh sách các nhân viên lên màn hình.\nTìm và in lý lịch một nhân viên bằng các nhập và họ tên hoặc mã số nhân viên.\n\n(**) Để lắp ráp một máy vi tính hoàn chỉnh cần phải có tối thiểu 10 linh kiện loại A và có thể lắp bổ sung thêm vào khoả ng tối đa 8 linh kiện loại B. Tại một cửa hàng vi tính cần quản lý bán hàng các loại linh kiện tại cửa hàng. Thông tin về một loại linh kiện gồm có: Tên linh kiện, quy cách, loại, đơn giá loại 1 (chất lượng tốt - số nguyên), đơn giá loại 2 (chất lượng thường - số nguyên). Viết chương trình thực hiện những công việc sau:\n\nNhập vào thông tin của các loại linh kiện có ở cửa hàng. Xuất danh sách các linh kiện đã nhập theo thứ tự tăng dần của loại linh kiện và tên linh kiện. Cho biết đã có đủ 10 linh kiện loại A cần thiết để lắp ráp máy tính hay chưa?\nVới giả định là cửa hàng đã có đủ 10 linh kiện loại A để lắp ráp máy. Nhập vào một số tiền để lắp ráp một máy tính. Có thể lắp được một máy tính hoàn chỉnh với các linh kiện toàn bộ theo đơn giá loại 1 hay đơn giá loại 2 hay không? Nếu số tiền trong khoảng giữa thì hãy tìm một phương án gồm những linh kiện theo đơn giá 1 và linh kiện theo đơn giá 2 để lắp?\nTất cả dữ liệu phải lưu ở tập tin.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9-cpp.html#tóm-tắt",
    "href": "chapter-9-cpp.html#tóm-tắt",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "9.3 TÓM TẮT",
    "text": "9.3 TÓM TẮT\nMục đích của kiểu dữ liệu tập tin cho phép chúng ta lưu lại những thông tin cần thiết tương đối lớn: những dữ liệu đầu vào, những kết quả của chương trình hoặc những dữ liệu dùng để kiểm tra chương trình. Khi thao tác trên tập tin phải thông qua 4 bước: Khai báo đối tượng luồng tập tin, Mở tập tin, Xử lý trên tập tin và cuối cùng là Đóng tập tin. Lưu ý khi mở tập tin để ghi thì phải cẩn thận với thao tác tạo mới hay chỉnh sửa nội dung tập tin, di chuyển con trỏ hợp lý để tránh mất thông tin. Sử dụng các phương thức thao tác trên tập tin phải dùng đúng loại luồng cho tập tin kiểu nhị phân hay kiểu văn bản.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-10-cpp.html",
    "href": "chapter-10-cpp.html",
    "title": "10  KIỂU DỮ LIỆU CON TRỎ",
    "section": "",
    "text": "10.1 LÝ THUYẾT\nChương này cung cấp một kiểu dữ liệu mới dùng để quản lý địa chỉ của các biến, cách cấp phát bộ nhớ động và các thao tác liên quan trong C và C++.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CON TRỎ</span>"
    ]
  },
  {
    "objectID": "chapter-10-cpp.html#lý-thuyết",
    "href": "chapter-10-cpp.html#lý-thuyết",
    "title": "10  KIỂU DỮ LIỆU CON TRỎ",
    "section": "",
    "text": "Khái niệm\n\nBộ nhớ máy tính bao gồm các ô nhớ, mỗi ô nhớ có kích thước 1 byte.\nMỗi ô nhớ có địa chỉ duy nhất là một số nguyên không âm.\nMỗi biến sẽ được gắn với một số ô nhớ liên tục.\nĐịa chỉ của biến là địa chỉ của ô nhớ đầu tiên.\nĐịa chỉ NULL (trong C) hoặc nullptr (trong C++) là địa chỉ 0, biểu thị con trỏ không trỏ đến vùng nhớ hợp lệ.\n\n\nBiến lưu địa chỉ là biến con trỏ.\n\n\n\nKhai báo con trỏ\n\n// C và C++\n⟨kiểu dữ liệu⟩ *⟨tên biến con trỏ⟩;\n\n\nKhai báo biến con trỏ và gán địa chỉ\n// C++\n#include &lt;cstddef&gt; // cho nullptr_t\n\nchar  *p1;\nint   *p2;\nfloat *p3;\n\np1 = (char*)0x0010; // Cần ép kiểu tường minh\np2 = (int*)0x0030;\np3 = nullptr;       // Sử dụng nullptr trong C++ hiện đại\n\n\n\nToán tử lấy địa chỉ\n\n// C và C++\n&⟨tên biến⟩\n\n\nLấy địa chỉ của một biến và lưu lại địa chỉ này vào biến con trỏ\n// C++\nchar c;\nint  n;\nchar *p1;\nint  *p2;\n\np1 = &c;\np2 = &n;\n\n\n\nToán tử truy xuất đến ô nhớ con trỏ quản lý\n\n// C và C++\n*⟨tên biến con trỏ⟩\n\n\nTruy xuất đến biến do biến con trỏ quản lý\n// C++\nint n;\nint *p;\np = &n;\n*p = 5; // Tương đương với n = 5;\nThao tác với biến con trỏ\n// C++\n#include &lt;iostream&gt;\n\nint main() {\n    int a = 5;\n    int *pa;\n    pa = &a;\n\n    std::cout &lt;&lt; \"Giá trị của a: \" &lt;&lt; a &lt;&lt; std::endl;         // In giá trị của a\n    std::cout &lt;&lt; \"Địa chỉ của a (giá trị của pa): \" &lt;&lt; pa &lt;&lt; std::endl;  // In địa chỉ của a\n    std::cout &lt;&lt; \"Giá trị tại địa chỉ pa trỏ tới: \" &lt;&lt; *pa &lt;&lt; std::endl; // In giá trị của a\n    std::cout &lt;&lt; \"Địa chỉ của chính con trỏ pa: \" &lt;&lt; &pa &lt;&lt; std::endl;   // In địa chỉ của biến con trỏ pa\n\n    return 0;\n}\n\n\n\nCon trỏ nhiều cấp\nBiến con trỏ cũng có địa chỉ của riêng nó.\n\n\nBiến con trỏ cấp 1 là con trỏ quản lý địa chỉ của biến thông thường.\nBiến con trỏ cấp k quản lý địa chỉ của con trỏ cấp k-1.\n\n\n\nCon trỏ cấp 1 p\n// C và C++\nint *p;\nCon trỏ cấp 2 q\n// C và C++\nint **q;\nCon trỏ cấp 3 r\n// C và C++\nint ***r;\n\n\nThao tác với biến con trỏ nhiều cấp\n// C++\n#include &lt;iostream&gt;\n\nint main() {\n    int a = 12;\n    int *p = &a;\n    int **q = &p;\n\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"**q = \" &lt;&lt; **q &lt;&lt; std::endl; // Truy xuất giá trị của a thông qua q\n    \n    return 0;\n}\n\n\n\nCon trỏ và tham số\n\nHàm hoanvi sử dụng hai tham số x,y là con trỏ (kiểu C).\n// C\nvoid hoanvi(int *x, int *y) \n{ \n    int t = *x; \n    *x = *y; \n    *y = t; \n} \n\nvoid main() \n{ \n    int a = 4, b = 7; \n    hoanvi(&a, &b); \n    printf(\"a = %d, b = %d\", a, b); \n} \nHàm hoanvi sử dụng tham chiếu (kiểu C++).\n// C++\n#include &lt;iostream&gt;\n\nvoid hoanvi(int &x, int &y) {\n    int t = x;\n    x = y;\n    y = t;\n}\n\nint main() {\n    int a = 4, b = 7;\n    hoanvi(a, b);\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; std::endl;\n    return 0;\n}\n\nCả hai cách đều hoán đổi giá trị của a và b. Tuy nhiên, cách dùng tham chiếu trong C++ thường an toàn và dễ đọc hơn.\n\n\n\n\nCác phép toán trên con trỏ\n\nToán tử cộng/trừ số nguyên\n\n// C và C++\n⟨con trỏ⟩ + ⟨số nguyên⟩\n⟨con trỏ⟩ - ⟨số nguyên⟩\nĐược hiểu là thực hiện phép tính số học ⟨địa chỉ⟩ ± ⟨số nguyên⟩ * sizeof(⟨kiểu dữ liệu⟩) và kết quả trả về cũng là một con trỏ cùng kiểu.\n\n\n// C++\nint a[10];\nint *p = a; // p trỏ tới a[0]\np = p + 2;  // p bây giờ trỏ tới a[2]\n\nint *q = &a[5];\nq = q - 3; // q bây giờ trỏ tới a[2]\np và q lúc này cùng trỏ tới phần tử a[2].\n\n\n\nToán tử trừ con trỏ\n\n// C và C++\n⟨con trỏ 1⟩ - ⟨con trỏ 2⟩\n⟨con trỏ 1⟩ và ⟨con trỏ 2⟩ phải cùng kiểu. Kết quả trả về là một số nguyên cho biết khoảng cách (số lượng phần tử) giữa hai con trỏ.\n\n\n// C++\nint a[100];\nint *p = &a[50];\nint *q = &a[10];\nint d = p - q; // d sẽ có giá trị là 40\nGiá trị của d là 50 - 10 = 40.\n\n\n\n\nCon trỏ và mảng 1 chiều tĩnh\nTên của mảng chính là một hằng con trỏ, trỏ tới địa chỉ của phần tử đầu tiên.\n\nKhai báo biến mảng a\n// C và C++\nint a[100];\nKhai báo biến con trỏ p,q\n// C và C++\nint *p,*q;\nGán địa chỉ cho p,q\n// C và C++\np = a;\nq = &a[0];\np và q sẽ có cùng giá trị địa chỉ. Do đó, a[i], *(a + i), *(p + i) và p[i] đều tương đương nhau.\n\n\n\nCon trỏ và cấu trúc\n\nTruy xuất thành phần của biến cấu trúc qua biến con trỏ\n// C và C++\n(*⟨biến con trỏ⟩).⟨tên thành phần⟩\n⟨biến con trỏ⟩-&gt;⟨tên thành phần⟩\n// C++\n#include &lt;iostream&gt;\n\nstruct PhanSo {\n    int tu, mau;\n};\n\nint main() {\n    PhanSo a;\n    PhanSo *p = &a;\n    \n    p-&gt;tu = 3;      // Cách dùng phổ biến\n    (*p).mau = 4;\n    \n    std::cout &lt;&lt; p-&gt;tu &lt;&lt; \"/\" &lt;&lt; p-&gt;mau &lt;&lt; std::endl;\n    return 0;\n}\n\n\n\nCon trỏ hàm\n\n\nCon trỏ hàm dùng để quản lý địa chỉ của một hàm.\nCó thể gọi hàm thực thi thông qua con trỏ hàm, cho phép truyền hàm như một tham số.\n\n\n\nKhai báo con trỏ hàm\n// C và C++\n⟨kiểu trả về⟩ (*⟨biến con trỏ hàm⟩)(⟨danh sách kiểu tham số⟩);\n// C++\nint (*pf1)(int);\nint (*pf2)(double, double);\n\npf1 quản lý địa chỉ của hàm có một tham số int và kiểu trả về int.\npf2 quản lý địa chỉ của hàm có hai tham số double và kiểu trả về int.\n\nGọi thực thi con trỏ hàm\n// C và C++\n⟨biến con trỏ hàm⟩(⟨danh sách đối số⟩);\n\n\nCác thao tác trên con trỏ hàm\n// C++\n#include &lt;iostream&gt;\n\nint Cong(int a, int b) {\n    return a + b;\n}\n\nint Tru(int a, int b) {\n    return a - b;\n}\n\nint main() {\n    int s;\n    int (*f)(int, int); // Khai báo con trỏ hàm\n\n    f = Cong; // f trỏ đến hàm Cong\n    s = f(5, 3); // Gọi hàm Cong qua con trỏ f\n    std::cout &lt;&lt; \"5 + 3 = \" &lt;&lt; s &lt;&lt; std::endl;\n\n    f = Tru; // f trỏ đến hàm Tru\n    s = f(5, 3); // Gọi hàm Tru qua con trỏ f\n    std::cout &lt;&lt; \"5 - 3 = \" &lt;&lt; s &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n\n\nCấp phát bộ nhớ động\n\nTrong C\n\nSử dụng các hàm trong thư viện &lt;cstdlib&gt; (hoặc &lt;malloc.h&gt; trong C cũ).\n\nXin cấp phát vùng nhớ:\nvoid* malloc(size_t size);\nXin cấp phát vùng nhớ theo khối và khởi tạo bằng 0:\nvoid* calloc(size_t num, size_t size);\nThu hồi bộ nhớ:\nvoid free(void* ptr);\n\n\n\n// C\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint *p = (int*)malloc(sizeof(int));\nint *q = (int*)calloc(10, sizeof(int)); // Cấp phát mảng 10 số nguyên\n\nif (p != NULL) {\n    *p = 100;\n}\n\nfree(p);\nfree(q);\n\n\n\nTrong C++\nC++ bổ sung thêm các toán tử quản lý bộ nhớ an toàn hơn về kiểu dữ liệu.\n\n\nCấp phát một đối tượng:\nnew ⟨kiểu dữ liệu⟩;\nCấp phát một mảng đối tượng:\nnew ⟨kiểu dữ liệu⟩[⟨số phần tử⟩];\nThu hồi một đối tượng:\ndelete ⟨biến con trỏ⟩;\nThu hồi một mảng đối tượng:\ndelete[] ⟨biến con trỏ⟩;\n\n\n\nBiến p chứa địa chỉ của một vùng nhớ cho một số nguyên, biến q chứa địa chỉ của một vùng nhớ cho một dãy 10 số nguyên.\n// C++\nint *p = new int;\nint *q = new int[10];\n\n*p = 50;\nq[0] = 1;\n\ndelete p;     // Thu hồi vùng nhớ của p\ndelete[] q;   // Thu hồi vùng nhớ của mảng q\n\n\nLưu ý quan trọng: Vùng nhớ cấp phát bằng new phải được giải phóng bằng delete. Vùng nhớ cấp phát bằng new[] phải được giải phóng bằng delete[]. Trộn lẫn chúng sẽ gây ra lỗi không xác định (Undefined Behavior).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CON TRỎ</span>"
    ]
  },
  {
    "objectID": "chapter-10-cpp.html#bài-tập",
    "href": "chapter-10-cpp.html#bài-tập",
    "title": "10  KIỂU DỮ LIỆU CON TRỎ",
    "section": "10.2 BÀI TẬP",
    "text": "10.2 BÀI TẬP\n\nBài tập cơ bản\n\nViết hàm hoán vị giá trị của hai biến số nguyên bằng cách sử dụng con trỏ.\nViết chương trình yêu cầu người dùng nhập vào một chuỗi ký tự, sau đó sử dụng con trỏ để đếm số ký tự trong chuỗi (không dùng strlen).\nViết chương trình khai báo một mảng số nguyên. Sử dụng một con trỏ để duyệt qua mảng và in ra giá trị của từng phần tử.\nViết hàm nhận vào một con trỏ kiểu int và giá trị của con trỏ đó. Hàm sẽ kiểm tra xem con trỏ có phải là nullptr hay không và in ra thông báo tương ứng.\n\n\n\nBài tập cấp phát động\n\nViết chương trình yêu cầu người dùng nhập vào một số nguyên n. Cấp phát động một mảng n số nguyên. Sau đó, cho người dùng nhập giá trị cho mảng này, tính tổng và in kết quả ra màn hình. Nhớ giải phóng bộ nhớ sau khi dùng xong.\nViết một hàm nhận vào một số nguyên n, cấp phát động một mảng n số nguyên, khởi tạo các phần tử của mảng bằng các số ngẫu nhiên từ 1 đến 100, sau đó trả về con trỏ tới mảng đó. Viết chương trình chính gọi hàm này và in mảng ra màn hình.\nĐịnh nghĩa một cấu trúc SinhVien gồm các trường: hoTen (chuỗi ký tự), mssv (số nguyên). Viết chương trình cấp phát động cho một biến kiểu SinhVien, cho người dùng nhập thông tin và in ra màn hình.\nMở rộng bài 7: Viết chương trình yêu cầu nhập số lượng sinh viên n, cấp phát động một mảng n SinhVien, cho phép nhập thông tin cho cả lớp và sau đó in danh sách lớp ra màn hình.\n\n\n\nBài tập nâng cao\n\nSử dụng con trỏ hàm, viết một hàm SapXep nhận vào một mảng số nguyên, kích thước mảng và một con trỏ hàm so sánh. Viết hai hàm so sánh: SoSanhTangDan và SoSanhGiamDan. Chương trình chính sẽ gọi hàm SapXep để sắp xếp mảng theo cả hai chiều.\nViết chương trình cấp phát động một ma trận m x n (m, n nhập từ bàn phím) bằng cách sử dụng con trỏ cấp 2 (int **matrix). Nhập giá trị cho ma trận và in ma trận ra màn hình. Đừng quên giải phóng bộ nhớ đúng cách.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CON TRỎ</span>"
    ]
  },
  {
    "objectID": "chapter-10-cpp.html#tóm-tắt",
    "href": "chapter-10-cpp.html#tóm-tắt",
    "title": "10  KIỂU DỮ LIỆU CON TRỎ",
    "section": "10.3 TÓM TẮT",
    "text": "10.3 TÓM TẮT\nCon trỏ là một khái niệm nền tảng, cho phép quản lý bộ nhớ một cách trực tiếp. Trong C++, dù có nhiều công cụ cấp cao hơn như tham chiếu và con trỏ thông minh (smart pointers), việc hiểu rõ con trỏ gốc và cách cấp phát bộ nhớ động với new/delete vẫn cực kỳ quan trọng để làm việc hiệu quả với các cấu trúc dữ liệu phức tạp và tối ưu hóa hiệu năng chương trình. Luôn nhớ quy tắc: cấp phát ở đâu, giải phóng ở đó, và sử dụng đúng cặp new/delete hoặc new[]/delete[] để tránh rò rỉ bộ nhớ.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CON TRỎ</span>"
    ]
  },
  {
    "objectID": "chapter-11-cpp.html",
    "href": "chapter-11-cpp.html",
    "title": "11  KỸ THUẬT ĐỆ QUI",
    "section": "",
    "text": "11.1 LÝ THUYẾT\nChương này giới thiệu phương pháp lập trình theo kỹ thuật đệ quy, phân loại, cách hoạt động và cách cài đặt các hàm đệ quy.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>KỸ THUẬT ĐỆ QUI</span>"
    ]
  },
  {
    "objectID": "chapter-11-cpp.html#lý-thuyết",
    "href": "chapter-11-cpp.html#lý-thuyết",
    "title": "11  KỸ THUẬT ĐỆ QUI",
    "section": "",
    "text": "Một khái niệm là khái niệm đệ qui nếu trong định nghĩa của nó có sử dụng lại chính nó\nMột hàm là hàm đệ qui nếu trong thân của hàm đó có những lệnh gọi lại chính nó một cách tường minh hay tiềm ẩn.\n\n\n\nNhững hình tự đồng dạng\n\n\n\n\n\n\n\nCác loại đệ qui\n\nĐệ qui tuyến tính\n\nTrong mỗi lần thực hiện, hàm gọi lại chính nó không quá một lần\n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm⟩(⟨danh sách tham số⟩) \n{ \n    if(⟨điều kiện dừng⟩) \n    {\n        ...         \n    } \n    else\n    {\n        ... \n        ⟨Tên hàm⟩(⟨danh sách tham số⟩);\n        ... \n    }\n} \n\n\nTính tổng S_{n}=1+2+...+n\nPhân tích bài toán\n\nPhần dừng: S_{0}=0\nPhần đệ qui: S_{n}=S_{n-1}+n với n&gt;0\n\nint TinhTong(int n) \n{ \n    if(n==0) \n        return 0; \n    else\n        return (TinhTong(n-1) + n); \n} \n\n\nTính P_{n}=n!\nPhân tích bài toán\n\nPhần dừng: P_{0}=1\nPhần đệ qui: P_{n}=P_{n-1}.n với n&gt;0\n\nint TinhGiaiThua(int n) \n{ \n    if(n==0) \n        return 1; \n    else\n        return (TinhGiaiThua(n-1) * n); \n} \n\n\n\nĐệ qui nhị phân\n\nTrong mỗi lần thực hiện, hàm gọi lại chính nó không quá hai lần\n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm⟩(⟨danh sách tham số⟩) \n{ \n    if(⟨điều kiện dừng⟩) \n    {\n        ... \n    } \n    else\n    {\n        ...\n        ⟨Tên hàm⟩(⟨danh sách tham số⟩);     \n        ... \n        ⟨Tên hàm⟩(⟨danh sách tham số⟩);     \n        ...\n    }\n} \n\n\nTính số f_{n} của dãy Fibonacci \\left\\{ 1,\\,1,\\,2,\\,3,\\,5,\\ldots\\right\\}\n\nPhần dừng: f_{0}=1 và f_{1}=1.\nPhần đệ qui: f_{n}=f_{n-1}+f_{n-2} với n&gt;1\n\nint Fibo(int n) \n{ \n    if(n==0 || n==1) \n        return 1; \n    else\n        return Fibo(n-1) + Fibo(n-2); \n} \n\n\nBài toán tháp Hà Nội\n\nPhần dừng: n=1 thì A\\to C\nPhần đệ qui:\n\nBước 1: Di chuyển n-1 đĩa trên cùng từ cọc A sang cọc B.\nBước 2: A\\to C.\nBước 3: Di chuyển n-1 đĩa trên cùng từ cọc B sang cọc C.\n\n\n// Hàm đệ quy giải bài toán Tháp Hà Nội\nvoid ThapHaNoi(int n, char A, char B, char C) {\n    if (n == 1) {\n        std::cout &lt;&lt; \"Di chuyen dia 1 tu \" &lt;&lt; A &lt;&lt; \" sang \" &lt;&lt; C &lt;&lt; std::endl;\n        return;\n    }\n\n    // Di chuyển n-1 đĩa từ A sang B, lấy C làm trung gian\n    ThapHaNoi(n - 1, A, C, B);\n\n    // Di chuyển đĩa lớn nhất (đĩa thứ n) từ A sang C\n    std::cout &lt;&lt; \"Di chuyen dia \" &lt;&lt; n &lt;&lt; \" tu \" &lt;&lt; A &lt;&lt; \" sang \" &lt;&lt; C &lt;&lt; std::endl;\n\n    // Di chuyển n-1 đĩa từ B sang C, lấy A làm trung gian\n    ThapHaNoi(n - 1, B, A, C);\n}\n\n\n\nĐệ qui phi tuyến\n\nTrong mỗi lần thực hiện hàm, có thể gọi lại chính nó hơn hai lần\n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm⟩(⟨danh sách tham số⟩) \n{ \n    if(⟨điều kiện dừng⟩) \n    {\n        ...         \n    } \n    else\n    for (int i = 1; i&lt;=n; i++)\n    { \n        ...\n        ⟨Tên hàm⟩(⟨danh sách tham số⟩);\n        ...\n    } \n}\n\n\nTính số hạng thứ n của dãy x_{n} được định nghĩa như sau:\n\\begin{array}{l}\nx_{0}=1\\\\\nx_{n}=n^{2}x_{0}+\\left(n-1\\right)^{2}x_{1}+...+1^{2}x_{n}\n\\end{array}\n\nPhần dừng: dựa trên định nghĩa\nPhần đệ qui: dựa trên định nghĩa\n\nint TinhXn(int n) \n{ \n    if(n==0) return 1; \n    int s = 0; \n    for (int i=1; i&lt;=n; i++) \n        s = s + i * i * TinhXn(n-i); \n    return s; \n} \n\n\n\nĐệ qui hỗ tương\n\nHàm thứ nhất và hàm thứ hai gọi qua lại lẫn nhau.\n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm 1⟩(⟨danh sách tham số⟩); \n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm 2⟩(⟨danh sách tham số⟩); \n...\n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm 1⟩(⟨danh sách tham số⟩) \n{ \n    ...\n    ⟨Tên hàm 2⟩(⟨danh sách tham số⟩); \n    ...\n} \n⟨Kiểu dữ liệu hàm⟩ ⟨Tên hàm 2⟩(⟨danh sách tham số⟩) \n{ \n    ...\n    ⟨Tên hàm 1⟩(⟨danh sách tham số⟩); \n    ...\n} \n\n\nTính số hạng thứ n của hai dãy x_{n} và y_{n} được định nghĩa như sau:\n\\begin{array}{l}\nx_{0}=1\\\\\ny_{0}=1\\\\\nx_{n}=x_{n-1}+y_{n-1}\\\\\ny_{n}=n^{2}x_{n-1}+y_{n-1}\n\\end{array}\n\nPhần dừng: dựa trên định nghĩa\nPhần đệ qui: dựa trên định nghĩa\n\nint TinhXn(int n);\nint TinhYn(int n);\nint TinhXn(int n) \n{ \n    if(n==0) return 1; \n    return TinhXn(n-1) + TinhYn(n-1); \n}\nint TinhYn(int n) \n{ \n    if(n==0) return 1; \n    return n*n*TinhXn(n-1) + TinhYn(n-1); \n} \n\n\n\n\nCác ví dụ\n\nViết hàm tính lũy thừa x^{n} bằng kỹ thuật đệ qui\nfloat TinhLuyThua(float x, int n)\n{\n    if(n==0) return 1;\n    else return x*TinhLuyThua(x,n-1);\n}\n\n\nViết hàm tính tổng các phần tử có giá trị chẵn của một dãy số kỹ thuật đệ qui.\nint TongChan(int a[], int n) \n{ \n    if(n==0) return 0; \n    int s = TongChan(a, n-1);\n    if(a[n-1]%2==0) s+=a[n-1]; \n    return s; \n}\n\n\nCho dãy số nguyên a gồm n phần tử có thứ tự tăng dần. Tìm phần tử có giá trị x có xuất hiện trong mảng không bằng kỹ thuật đệ qui.\nint TimNhiPhan(int a[], int l, int r, int x)\n{\n    int m = (l+r)/2; \n    if(l&gt;r) return -1; // Không có phần tử x\n    if(a[m]==x)\n        return m; // Trả về vị trí tìm thấy\n    if(a[m]&gt;x) \n        return TimNhiPhan(a, l, m-1, x); \n    if(a[m]&lt;x) \n        return TimNhiPhan(a, m+1, r, x);    \n}",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>KỸ THUẬT ĐỆ QUI</span>"
    ]
  },
  {
    "objectID": "chapter-11-cpp.html#bài-tập",
    "href": "chapter-11-cpp.html#bài-tập",
    "title": "11  KỸ THUẬT ĐỆ QUI",
    "section": "11.2 BÀI TẬP",
    "text": "11.2 BÀI TẬP\n\nBài tập cơ bản\n\nCài đặt bằng đệ qui lại những bài tập ở chương mảng một chiều.\nTìm chữ số có giá trị lớn nhất của số nguyên dương n.\nHãy xây dựng một dãy gồm N số có giá trị từ 1 đến K cho trước, sao cho không có hai dãy con liên tiếp đứng kề nhau. Ví dụ, N = 6 và K = 3 thì kết quả: 121312\nTìm ước số chung lớn nhất của hai số nguyên dương a và b.\nTìm chữ số đầu tiên của số nguyên dương n.\nTìm dãy nhị phân dài nhất sao cho trên dãy này không có hai bộ k bất kỳ trùng nhau. Bộ k là dãy con có k số liên tiếp nhau trên dãy tìm được. Ví dụ, k = 3 thì kết quả là 0001011100\nTính P(n)=1.3.5...(2n+1) với n&gt;0\nTính P(n)=1+3+5+...+(2n+1) với n&gt;0\nTính P(n)=1-2+3-...+(-1)^{n+1}n với n&gt;0\nTính P(n)=1+1.2+1.2.3+...+1.2.3...n với n&gt;0\nTính P(n)=1+(1+2)+(1+2+3)+...+(1+2+3+...+n) với n&gt;0\nTính P(n)=1^{2}+2^{2}+3^{2}+...+n^{2} với n&gt;0\nTính P(n)=1+\\frac{1}{2}+\\frac{1}{3}+...\\frac{1}{n} với n&gt;0\nTính P(n)=1+\\frac{1}{1+2}+\\frac{1}{1+2+3}+...+\\frac{1}{1+2+3+...+n} với n&gt;0\nTính P(x,n)=x^{n} với n là số nguyên không âm\n\n\n\nBài tập luyện tập và nâng cao\n\nCho số nguyên dương n. In ra biểu diễn nhị phân của n.\n(*) Tính S(n)=\\sqrt{n+\\sqrt{n-1+\\sqrt{n-2+...+\\sqrt{1}}}} với n&gt;0\n(*) Tính S(n)=\\sqrt{1+\\sqrt{2+\\sqrt{3+...+\\sqrt{n}}}} với n&gt;0\n(*) Tính \\frac{1}{1+\\frac{1}{1+\\frac{1}{1+...+\\frac{1}{1+\\frac{1}{1}}}}} với n&gt;0\n(**) Cài đặt bài toán mã đi tuần.\n(**) Cài đặt bài toán tám hậu.\n(*) Cài đặt hàm tính x.y với x,y là các số nguyên không âm mà chỉ được dùng các tính cộng và shift left và shift right thông qua công thức sau x.y=\\begin{cases}\n0 & \\text{nếu }x=0\\\\\n\\left(x\\gg1\\right).\\left(y\\ll1\\right) & \\text{nếu }x\\text{ là số chẵn}\\\\\n\\left(x\\gg1\\right).\\left(y\\ll1\\right)+y & \\text{nếu }x\\text{ là số lẻ}\n\\end{cases}\nCài đặt hàm in ra tất cả các chỉnh hợp chập k của n phần tử, với k\\in\\left[0,...,n\\right].\nCài đặt hàm in ra tất cả các hoán vị của n phần tử.\nCài đặt hàm in ra tất cả các tổ hợp chập k của n phần tử, với k\\in\\left[0,...,n\\right].",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>KỸ THUẬT ĐỆ QUI</span>"
    ]
  },
  {
    "objectID": "chapter-11-cpp.html#tóm-tắt",
    "href": "chapter-11-cpp.html#tóm-tắt",
    "title": "11  KỸ THUẬT ĐỆ QUI",
    "section": "11.3 TÓM TẮT",
    "text": "11.3 TÓM TẮT\nĐệ qui cung cấp cho ta cơ chế giải quyết các bài toán phức tạp một cách đơn giản hơn. Xây dựng hàm đệ qui thông qua việc xác định điều kiện dừng và bước thực hiện tiếp theo. Chỉ nên cài đặt bằng phương pháp đệ qui khi không còn cách giải quyết bằng cách lặp thông thường.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>KỸ THUẬT ĐỆ QUI</span>"
    ]
  },
  {
    "objectID": "chapter-12-cpp.html",
    "href": "chapter-12-cpp.html",
    "title": "12  LẬP TRÌNH ĐƠN THỂ",
    "section": "",
    "text": "12.1 LÝ THUYẾT\nChương này sẽ giới thiệu về phương pháp lập trình đơn thể (modular programming), một kỹ thuật tổ chức mã nguồn hiệu quả để quản lý các dự án phần mềm phức tạp.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>LẬP TRÌNH ĐƠN THỂ</span>"
    ]
  },
  {
    "objectID": "chapter-12-cpp.html#lý-thuyết",
    "href": "chapter-12-cpp.html#lý-thuyết",
    "title": "12  LẬP TRÌNH ĐƠN THỂ",
    "section": "",
    "text": "Khái niệm\n\nLập trình đơn thể là một phương pháp thiết kế phần mềm tập trung vào việc phân tách một chương trình thành các phần độc lập, có thể quản lý được, gọi là các đơn thể (modules). Mỗi đơn thể chứa đựng một tập hợp các hàm và dữ liệu liên quan để thực hiện một chức năng cụ thể và trọn vẹn.\nThay vì viết toàn bộ mã nguồn vào một tệp lớn, chúng ta chia chương trình thành các tệp nhỏ hơn. Thông thường, một đơn thể bao gồm:\n\nTệp tiêu đề (Header File - .h hoặc .hpp): Đóng vai trò là “giao diện công khai” của đơn thể. Nó khai báo những gì mà đơn thể cung cấp cho các phần khác của chương trình, chẳng hạn như nguyên mẫu hàm, định nghĩa lớp, hằng số, và các kiểu dữ liệu.\nTệp mã nguồn (Source File - .cpp): Chứa phần “cài đặt chi tiết” của đơn thể. Nó định nghĩa và hiện thực hóa các chức năng đã được khai báo trong tệp tiêu đề.\n\nViệc phân chia này giúp quá trình lập trình trở nên dễ kiểm soát, dễ kiểm lỗi và bảo trì hơn. Nó cũng giúp tránh giới hạn về kích thước tệp của một số trình biên dịch cũ.\nLập trình đơn thể liên quan chặt chẽ đến lập trình cấu trúc và lập trình hướng đối tượng, vì tất cả đều có chung mục tiêu là làm cho việc xây dựng các hệ thống phần mềm lớn trở nên khả thi hơn bằng cách phân rã chúng thành những thành phần nhỏ, dễ quản lý.\n\n\n\nPhương pháp\nQuá trình thực hiện lập trình đơn thể trong C++ thường bao gồm các bước sau:\n1. Thiết kế và Tách biệt Chức năng\n\nXác định các chức năng chính của chương trình.\nNhóm các hàm và dữ liệu có liên quan chặt chẽ vào cùng một đơn thể. Ví dụ: một chương trình máy tính có thể có các đơn thể như PhepToanSoHoc, GiaoDienNguoiDung, LuuTruDuLieu.\n\n2. Tạo Tệp Tiêu đề (.h)\n\nTệp này chỉ chứa các khai báo, không chứa mã cài đặt chi tiết.\nSử dụng bộ bảo vệ tiêu đề (header guards) để tránh lỗi “định nghĩa lại” khi một tệp tiêu đề được #include nhiều lần trong quá trình biên dịch.\n\n\nVí dụ về tệp MathUtils.h\n// MathUtils.h\n#ifndef MATH_UTILS_H  // Nếu MATH_UTILS_H chưa được định nghĩa\n#define MATH_UTILS_H  // Thì định nghĩa nó\n\n// Khai báo nguyên mẫu các hàm\nint cong(int a, int b);\nint tru(int a, int b);\n\n#endif // Kết thúc bộ bảo vệ\n\n3. Tạo Tệp Mã nguồn (.cpp)\n\nTệp này chứa phần cài đặt (định nghĩa) cho các hàm đã khai báo trong tệp tiêu đề tương ứng.\nPhải #include tệp tiêu đề của chính nó để trình biên dịch có thể kiểm tra sự nhất quán giữa khai báo và định nghĩa.\n\n\nVí dụ về tệp MathUtils.cpp\n// MathUtils.cpp\n#include \"MathUtils.h\" // Include tệp tiêu đề tương ứng\n\n// Định nghĩa (cài đặt) các hàm\nint cong(int a, int b) {\n    return a + b;\n}\n\nint tru(int a, int b) {\n    return a - b;\n}\n\n4. Sử dụng Đơn thể trong Chương trình Chính\n\nTệp chứa hàm main() (hoặc một đơn thể khác) sẽ #include tệp tiêu đề của đơn thể mà nó muốn sử dụng.\nLưu ý: Sử dụng dấu ngoặc kép \"\" cho các tệp tiêu đề cục bộ của dự án và dấu ngoặc nhọn &lt;&gt; cho các thư viện hệ thống.\n\n\nVí dụ về tệp main.cpp\n// main.cpp\n#include &lt;iostream&gt;\n#include \"MathUtils.h\" // Sử dụng đơn thể MathUtils\n\nint main() {\n    int x = 10;\n    int y = 5;\n\n    std::cout &lt;&lt; \"Tong: \" &lt;&lt; cong(x, y) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Hieu: \" &lt;&lt; tru(x, y) &lt;&lt; std::endl;\n\n    return 0;\n}\n\n5. Biên dịch và Liên kết (Compile and Link)\nĐây là bước quan trọng nhất để hiểu cách các đơn thể hoạt động cùng nhau.\n\nBiên dịch (Compilation): Mỗi tệp .cpp được biên dịch độc lập thành một tệp đối tượng (object file - .o hoặc .obj). Tệp đối tượng chứa mã máy nhưng chưa phải là một chương trình hoàn chỉnh.\nLiên kết (Linking): Trình liên kết (linker) sẽ kết hợp tất cả các tệp đối tượng (main.o, MathUtils.o, v.v.) và các thư viện cần thiết lại với nhau để tạo thành một tệp thực thi duy nhất (ví dụ: my_program.exe).\n\n\nVí dụ biên dịch bằng g++ trên dòng lệnh:\n# Bước 1: Biên dịch mỗi tệp .cpp thành tệp .o tương ứng\ng++ -c main.cpp -o main.o\ng++ -c MathUtils.cpp -o MathUtils.o\n\n# Bước 2: Liên kết tất cả các tệp .o lại để tạo tệp thực thi\ng++ main.o MathUtils.o -o MyCalculator\n\n\n\nLợi ích của Lập trình đơn thể\n\nTái sử dụng mã (Code Reusability): Một đơn thể (ví dụ: MathUtils) có thể được sử dụng lại trong nhiều dự án khác nhau mà không cần viết lại mã.\nBảo trì dễ dàng (Easier Maintenance): Khi cần sửa lỗi hoặc cải thiện một chức năng, bạn chỉ cần chỉnh sửa tệp .cpp của đơn thể đó mà không ảnh hưởng đến các phần khác của chương trình, miễn là giao diện trong tệp .h không thay đổi.\nPhát triển song song (Parallel Development): Các lập trình viên khác nhau có thể làm việc trên các đơn thể khác nhau cùng một lúc, giúp tăng tốc độ phát triển dự án.\nTính trừu tượng (Abstraction): Người sử dụng đơn thể chỉ cần biết cần làm gì (thông qua tệp .h), không cần biết làm như thế nào (chi tiết trong tệp .cpp).\nTổ chức và quản lý mã nguồn tốt hơn: Dự án được cấu trúc rõ ràng, giúp người mới dễ dàng tìm hiểu và tham gia.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>LẬP TRÌNH ĐƠN THỂ</span>"
    ]
  },
  {
    "objectID": "chapter-12-cpp.html#bài-tập",
    "href": "chapter-12-cpp.html#bài-tập",
    "title": "12  LẬP TRÌNH ĐƠN THỂ",
    "section": "12.2 BÀI TẬP",
    "text": "12.2 BÀI TẬP\n\nBài tập 1: Quản lý Chuỗi ký tự\nTạo một đơn thể StringUtils để thực hiện các thao tác trên chuỗi.\n\nTệp StringUtils.h:\n\nKhai báo hàm int tinhChieuDai(const char* str); để tính chiều dài chuỗi.\nKhai báo hàm void daoNguocChuoi(char* str); để đảo ngược một chuỗi.\n\nTệp StringUtils.cpp:\n\nCài đặt hai hàm đã khai báo ở trên.\n\nTệp main.cpp:\n\n#include \"StringUtils.h\".\nTạo một chuỗi, ví dụ char myName[] = \"Hello\";.\nGọi hàm tinhChieuDai để in ra chiều dài của chuỗi.\nGọi hàm daoNguocChuoi để đảo ngược chuỗi và in kết quả ra màn hình.\n\n\n\n\nBài tập 2: Quản lý Mảng\nTạo một đơn thể ArrayUtils để xử lý mảng số nguyên.\n\nTệp ArrayUtils.h:\n\nKhai báo hàm void inMang(const int arr[], int size);\nKhai báo hàm int timGiaTriLonNhat(const int arr[], int size);\nKhai báo hàm void sapXepTangDan(int arr[], int size);\n\nTệp ArrayUtils.cpp:\n\nCài đặt các hàm trên. Hàm sắp xếp có thể dùng thuật toán đơn giản như Bubble Sort.\n\nTệp main.cpp:\n\n#include \"ArrayUtils.h\".\nKhởi tạo một mảng số nguyên.\nSử dụng các hàm từ ArrayUtils để in mảng, tìm giá trị lớn nhất, sắp xếp mảng và in lại mảng sau khi sắp xếp.\n\n\n\n\nBài tập 3: Quản lý Sinh viên\nTạo một đơn thể để quản lý thông tin cơ bản của sinh viên.\n\nTệp SinhVien.h:\n\nĐịnh nghĩa một cấu trúc struct SinhVien { char hoTen[50]; float diemTB; };.\nKhai báo hàm void nhapThongTin(SinhVien& sv);\nKhai báo hàm void xuatThongTin(const SinhVien& sv);\n\nTệp SinhVien.cpp:\n\nCài đặt hai hàm trên. Hàm nhập sẽ yêu cầu người dùng nhập họ tên và điểm trung bình từ bàn phím.\n\nTệp main.cpp:\n\n#include \"SinhVien.h\".\nKhai báo một biến kiểu SinhVien.\nGọi hàm nhapThongTin và sau đó là xuatThongTin để hiển thị lại thông tin vừa nhập.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>LẬP TRÌNH ĐƠN THỂ</span>"
    ]
  },
  {
    "objectID": "chapter-12-cpp.html#tóm-tắt",
    "href": "chapter-12-cpp.html#tóm-tắt",
    "title": "12  LẬP TRÌNH ĐƠN THỂ",
    "section": "12.3 TÓM TẮT",
    "text": "12.3 TÓM TẮT\nLập trình đơn thể là một kỹ thuật thiết yếu để tổ chức các dự án phần mềm. Bằng cách chia chương trình thành các đơn thể độc lập—mỗi đơn thể gồm một tệp tiêu đề .h cho giao diện và một tệp mã nguồn .cpp cho việc cài đặt—chúng ta có thể xây dựng các hệ thống dễ bảo trì, dễ mở rộng và cho phép tái sử dụng mã nguồn hiệu quả. Quá trình biên dịch và liên kết riêng biệt chính là cơ chế kỹ thuật cho phép các đơn thể này hoạt động hài hòa với nhau để tạo thành một chương trình hoàn chỉnh.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>LẬP TRÌNH ĐƠN THỂ</span>"
    ]
  },
  {
    "objectID": "ex-func.html",
    "href": "ex-func.html",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "",
    "text": "13.1 Bài tập 1",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-1",
    "href": "ex-func.html#bài-tập-1",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "",
    "text": "#include&lt;iostream&gt;\nusing namespace std;\nvoid func(int& a, int b, int &c)\n{\n    a += b;\n    b += c;\n    c += a;\n}\nvoid main()\n{\n    int a = 1, b = 2, c = 3;\n    func(b, c, a);\n    cout &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; c &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-2",
    "href": "ex-func.html#bài-tập-2",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "13.2 Bài tập 2",
    "text": "13.2 Bài tập 2\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint a = 1, b = 2, c = 3;\nint func(int& a, int b)\n{\n    a += c + 2;\n    b -= a;\n    return a;\n}\nvoid main()\n{\n    c = func(b, b);\n    cout &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; c &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-3",
    "href": "ex-func.html#bài-tập-3",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "13.3 Bài tập 3",
    "text": "13.3 Bài tập 3\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint func(int a, int& b)\n{\n    a += b + 4;\n    b -= a;\n    return a;\n}\nvoid main()\n{\n    int x = 5;\n    int y = func(3, x);\n    cout &lt;&lt; y &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-4",
    "href": "ex-func.html#bài-tập-4",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "13.4 Bài tập 4",
    "text": "13.4 Bài tập 4\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint func2(int& a, int b)\n{\n    a += b + 3;\n    b -= a;\n    return a;\n}\nint func1(int& a, int& b)\n{\n    a += b + 4;\n    b -= a;\n    return func2(a, b);\n}\nvoid main()\n{\n    int x = 5;\n    cout &lt;&lt; func1(x, x) &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-5",
    "href": "ex-func.html#bài-tập-5",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "13.5 Bài tập 5",
    "text": "13.5 Bài tập 5\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint func(int a, int& b)\n{\n    a += b + 4;\n    b -= a;\n    return a;\n}\nvoid main()\n{\n    int x = 5;\n    cout &lt;&lt; func(func(3, x), x) &lt;&lt; endl;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "ex-func.html#bài-tập-6",
    "href": "ex-func.html#bài-tập-6",
    "title": "13  BÀI TẬP HÀM CHẠY TAY",
    "section": "13.6 Bài tập 6",
    "text": "13.6 Bài tập 6\n\n\n#include&lt;iostream&gt;\nusing namespace std;\nint func(int a, int& b, int *pc)\n{\n    a = b + *pc;\n    b = a + *pc;\n    *pc = b + a;\n    return b;\n}\nvoid main()\n{\n    int x = 5, y = 3, z = 4;\n    z = func(x, y, &y);\n    cout &lt;&lt; x &lt;&lt; endl;\n    cout &lt;&lt; y &lt;&lt; endl;\n    cout &lt;&lt; z &lt;&lt; endl;\n}\n\n\n\nStack table\n\n\n\n\n\n\n\nvariable\ncontext\nvalue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>BÀI TẬP HÀM CHẠY TAY</span>"
    ]
  },
  {
    "objectID": "extra-fractal.html",
    "href": "extra-fractal.html",
    "title": "14  FRACTAL",
    "section": "",
    "text": "14.1 Tổng quan về Fractal\nFractal là một môn hình học nghiên cứu các đối tượng có đặc tính tự đồng dạng (self-similarity). Đây là thuộc tính mà khi ta phóng to một phần nhỏ của đối tượng, phần đó lại mang hình ảnh giống hệt như toàn bộ đối tượng. Đặc điểm này xuất hiện rất nhiều trong thế giới tự nhiên, ví dụ như hình dạng của cây cối, đường bờ biển, các dãy núi, hay các gân lá.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>FRACTAL</span>"
    ]
  },
  {
    "objectID": "extra-fractal.html#tổng-quan-về-fractal",
    "href": "extra-fractal.html#tổng-quan-về-fractal",
    "title": "14  FRACTAL",
    "section": "",
    "text": "Ứng dụng của Fractal\nĐồ họa fractal có nhiều ứng dụng thực tiễn:\n\nTạo ảnh: Dùng để tạo ra các hình ảnh tự nhiên phức tạp như mây, núi, mặt nước, cây cối.\nNén ảnh: Các thuật toán nén ảnh dựa trên fractal khai thác sự lặp lại cấu trúc trong ảnh để giảm dung lượng lưu trữ.\nNghiên cứu khoa học: Mô hình hóa các hiện tượng hỗn loạn, cấu trúc vật chất, và các hệ thống động lực phức tạp.\n\n\n\nCác ví dụ Fractal cổ điển\nNhiều fractal được xây dựng bằng cách lặp đi lặp lại một quy tắc sinh đơn giản:\n\nĐường cong Von Koch (Koch Curve):\n\nTập gốc (n=0): Một đoạn thẳng.\nQuy tắc sinh: Chia đoạn thẳng làm 3 phần bằng nhau. Bỏ đoạn ở giữa và thay bằng hai đoạn thẳng tạo thành một tam giác đều.\nLặp lại: Áp dụng quy tắc này cho tất cả các đoạn thẳng mới.\n\n\n\n\n\n\n\n\nĐường cong Minkowski:\n\nTập gốc (n=0): Một đoạn thẳng.\nQuy tắc sinh: Chia đoạn thẳng làm 4 phần. Bỏ 2 đoạn giữa và thay thế bằng 6 đoạn thẳng mới.\n\n\n\n\n\n\n\n\nBông tuyết Von Koch (Koch Snowflake):\n\nTập gốc (n=0): Một hình tam giác đều.\nQuy tắc sinh: Áp dụng quy tắc sinh của đường cong Von Koch lên cả ba cạnh của tam giác.\n\n\n\n\n\n\n\n\n\n\n\nHòn đảo Minkowski:\n\nTập gốc (n=0): Một hình vuông.\nQuy tắc sinh: Áp dụng quy tắc sinh của đường cong Minkowski lên cả bốn cạnh của hình vuông.\n\n\n\n\n\n\nTam giác Sierpinski:\n\nTập gốc (n=0): Một tam giác đều đặc.\nQuy tắc sinh: Chia tam giác thành 4 tam giác đều nhỏ hơn bằng cách nối trung điểm 3 cạnh. Bỏ đi tam giác ở giữa.\nLặp lại: Áp dụng quy tắc này cho 3 tam giác đều còn lại.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSố chiều tự đồng dạng (Fractal Dimension)\nMột đặc điểm quan trọng của fractal là “số chiều” của chúng không phải lúc nào cũng là số nguyên (như 1D, 2D, 3D). Số chiều tự đồng dạng (D) được định nghĩa dựa trên mối quan hệ giữa số lượng bản sao tự đồng dạng (N) và tỉ lệ co (s).\n\nNếu một hình H được chia thành N phần, mỗi phần là bản sao của H được thu nhỏ với tỉ lệ s, thì số chiều D được tính bằng:\nD = \\frac{\\log(N)}{\\log(1/s)}\n\n\nĐoạn thẳng (1D): Chia thành N đoạn nhỏ, tỉ lệ co s = 1/N. D = \\frac{\\log(N)}{\\log(1 / (1/N))} = \\frac{\\log(N)}{\\log(N)} = 1\n\n\n\n\n\nHình vuông (2D): Chia thành N \\times N = N^2 hình vuông nhỏ, tỉ lệ co s = 1/N. D = \\frac{\\log(N^2)}{\\log(1 / (1/N))} = \\frac{2 \\log(N)}{\\log(N)} = 2\n\n\n\n\n\nHình lập phương (3D): Chia thành N \\times N = N^3 lập phương nhỏ, tỉ lệ co s = 1/N. D = \\frac{\\log(N^3)}{\\log(1 / (1/N))} = \\frac{3 \\log(N)}{\\log(N)} = 3\n\n\n\n\n\nĐường cong Von Koch: Mỗi đoạn được thay thế bằng 4 đoạn nhỏ hơn (N=4), mỗi đoạn mới có độ dài bằng 1/3 đoạn cũ (s=1/3). D = \\frac{\\log(4)}{\\log(1 / (1/3))} = \\frac{\\log(4)}{\\log(3)} \\approx 1.26 Giá trị 1.26 (lớn hơn 1D của đường thẳng nhưng nhỏ hơn 2D của hình vuông) chính là “số chiều fractal” của nó.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>FRACTAL</span>"
    ]
  },
  {
    "objectID": "extra-fractal.html#hệ-hàm-lặp-ifs",
    "href": "extra-fractal.html#hệ-hàm-lặp-ifs",
    "title": "14  FRACTAL",
    "section": "14.2 Hệ hàm lặp (IFS)",
    "text": "14.2 Hệ hàm lặp (IFS)\nIFS (Iterated Function Systems) là một cơ sở toán học vững chắc để định nghĩa và tạo ra các hình fractal.\n\nCơ sở toán học\n\nKhông gian Hausdorff (H(X)):\n\nĐây là một không gian đặc biệt mà mỗi “phần tử” của nó là một tập hợp con (cụ thể là tập compact, khác rỗng) từ X.\nNgười ta định nghĩa khoảng cách Hausdorff h(A, B) giữa hai tập hợp A và B.\n\n\n\n\n\n\n\n\nÁnh xạ co (Contraction Mapping):\n\nTrong một không gian Metric đầy đủ (X, d) (nơi ta có thể đo khoảng cách d).\nMột ánh xạ T được gọi là ánh xạ co nếu nó luôn kéo các điểm lại gần nhau hơn.\nTức là, tồn tại k (với 0 &lt; k &lt; 1) sao cho: d(T(x'), T(x'')) \\le k \\cdot d(x', x'') với mọi điểm x', x'' trong X.\n\n\n\n\n\n\n\n\nTính chất quan trọng: Mọi ánh xạ co đều có một điểm bất động duy nhất. Nếu ta bắt đầu từ một điểm c bất kỳ và lặp x_{n+1} = T(x_n), dãy x_n sẽ luôn hội tụ về điểm bất động đó.\n\n\n\n\n\nMột hệ hàm lặp (IFS) là một tập hợp các ánh xạ co \\{T_1, T_2, \\dots, T_N\\} trên X.\nTa định nghĩa một ánh xạ co T mới trên không gian Hausdorff H(X) như sau: T(A) = T_1(A) \\cup T_2(A) \\cup \\dots \\cup T_N(A) (trong đó T_i(A) = \\{T_i(x) \\mid x \\in A\\}).\nVì T cũng là một ánh xạ co (trong không gian Hausdorff), nó cũng có một “điểm bất động” duy nhất. “Điểm bất động” này là một tập hợp, và đó chính là hấp tử (attractor), hay hình fractal, của hệ IFS.\n\n\n\n\n\n\n\n\n\nThuật toán tạo hình Fractal từ IFS\nCó hai thuật toán chính để vẽ hấp tử của IFS:\n\nThuật toán lặp xác định (Deterministic Algorithm):\n\nBắt đầu với một hình gốc S bất kỳ (ví dụ, một hình tam giác).\nLặp lại n lần: S = T(S) = T_1(S) \\cup T_2(S) \\cup \\dots \\cup T_N(S)\nHình ảnh sẽ hội tụ về fractal.\n\n\nVí dụ tam giác đều (Tam giác Sierpinski): Dùng 3 phép biến đổi affine (tỉ lệ + tịnh tiến)\n\nT_1: Tỉ lệ (0.5, 0.5)\nT_2: Tỉ lệ (0.5, 0.5) + Tịnh tiến (0.5, 0)\nT_3: Tỉ lệ (0.5, 0.5) + Tịnh tiến (0.25, 0.433)\n\n\n\nVí dụ tam giác vuông: Dùng 3 phép biến đổi affine (tỉ lệ + tịnh tiến)\n\nT_1: Tỉ lệ (0.5, 0.5)\nT_2: Tỉ lệ (0.5, 0.5) + Tịnh tiến (0.5, 0)\nT_3: Tỉ lệ (0.5, 0.5) + Tịnh tiến (0.0, 0.5)\n\n\n\n\nThuật toán lặp ngẫu nhiên (Random Algorithm):\n\nInput: Các phép biến đổi \\{T_1, \\dots, T_N\\}, một điểm bắt đầu P_0 = (x_0, y_0), và số lần lặp k.\n\nVẽ điểm P_0.\nLặp i từ 0 đến k:\n\nChọn ngẫu nhiên một phép biến đổi T từ tập IFS.\nTính điểm tiếp theo: P_{i+1} = T(P_i).\nVẽ điểm P_{i+1}.\n\n\nSau một số lần lặp (ví dụ k=10000), tập hợp các điểm được vẽ sẽ hiện lên hình dạng của fractal.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>FRACTAL</span>"
    ]
  },
  {
    "objectID": "extra-fractal.html#hệ-thống-l-system",
    "href": "extra-fractal.html#hệ-thống-l-system",
    "title": "14  FRACTAL",
    "section": "14.3 Hệ thống (L-System)",
    "text": "14.3 Hệ thống (L-System)\nL-System (Lindenmayer System) là một hệ thống văn phạm hình thức, ban đầu được phát triển để mô hình hóa sự phát triển của thực vật. Nó tạo ra fractal bằng cách viết lại chuỗi (string rewriting).\n\nĐồ họa Turtle (Turtle Graphics)\nL-System thường được vẽ bằng Đồ họa Turtle. Một con “rùa” (bút vẽ) có 3 thuộc tính:\n\nVị trí (p)\nHướng (\\alpha)\nTham số vẽ: bước nhảy \\Delta d và góc quay \\Delta \\alpha.\n\nCác ký hiệu trong chuỗi L-System được diễn giải thành lệnh điều khiển “rùa”:\n\n\n\n\n\n\n\nLệnh\nNội dung\n\n\n\n\nF\nVẽ tới trước một đoạn \\Delta d.\n\n\n+\nQuay bút vẽ sang trái một góc \\Delta \\alpha.\n\n\n-\nQuay bút vẽ sang phải một góc \\Delta \\alpha.\n\n\n[\nLưu lại vị trí (p) và hướng (\\alpha) hiện tại của rùa (đẩy vào stack).\n\n\n]\nPhục hồi lại vị trí (p) và hướng (\\alpha) đã lưu (pop khỏi stack).\n\n\n\n\n\n\n\nĐịnh nghĩa L-System\nMột L-System bao gồm:\n\nTập ký hiệu: Các ký tự mà rùa hiểu (ví dụ: F, +, -, [, ]).\nTiền đề (Axiom) s_0: Chuỗi ký tự ban đầu.\nTập luật sinh (Production Rules): Các quy tắc thay thế ký tự. Ví dụ: F \\to F+F-F.\n\n\n\nQuá trình thực hiện:\n\nBắt đầu từ tiên đề s_0.\nThực hiện lặp n lần: Ở mỗi bước, áp dụng đồng thời các luật sinh cho mọi ký tự trong chuỗi hiện tại để tạo ra chuỗi mới (s_0 \\to s_1 \\to s_2 \\to \\dots \\to s_n).\nDùng Đồ họa Turtle để vẽ chuỗi s_n cuối cùng.\n\n\n\n\n\nVí dụ L-System",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>FRACTAL</span>"
    ]
  },
  {
    "objectID": "extra-fractal.html#tập-mandelbrot",
    "href": "extra-fractal.html#tập-mandelbrot",
    "title": "14  FRACTAL",
    "section": "14.4 Tập Mandelbrot",
    "text": "14.4 Tập Mandelbrot\nTập Mandelbrot là một trong những fractal nổi tiếng nhất, được định nghĩa trong mặt phẳng số phức.\n\nĐịnh nghĩa\n\nTập Mandelbrot được định nghĩa dựa trên một biểu thức đệ quy đơn giản:\n\nBắt đầu với z_0 = 0 + 0i.\nLặp lại: z_{n+1} = z_n^2 + c.\n\nTrong đó c là một số phức. Tập Mandelbrot là tập hợp tất cả các số phức c sao cho dãy \\{z_n\\} không tiến ra vô cực (tức là dãy bị chặn).\n\n\n\nTính chất hội tụ\nMột tính chất then chốt để vẽ tập Mandelbrot: Nếu tồn tại một k nào đó mà mô-đun (độ lớn) của z_k vượt quá 2 (tức là |z_k| &gt; 2), thì dãy \\{z_n\\} chắc chắn sẽ tiến ra vô cực.\n\n\n\n\n\n\n\nThuật toán vẽ tập Mandelbrot\nThuật toán này kiểm tra từng điểm c trên mặt phẳng phức (tương ứng với từng pixel trên màn hình) để xem nó có thuộc tập hợp hay không.\nCho mỗi pixel (x, y) trên màn hình:\n\nÁnh xạ: Chuyển đổi tọa độ pixel (x, y) thành một số phức c = x + yi trong một vùng của mặt phẳng phức.\nKiểm tra hội tụ:\n\nKhởi tạo z = 0.\nĐặt một số lần lặp tối đa (ví dụ N = 100).\nLặp i từ 0 đến N:\n\nTính z = z^2 + c.\nNếu |z| &gt; 2: Dãy tiến ra vô cực. Điểm c không thuộc tập Mandelbrot. Dừng lặp.\n\nNếu vòng lặp kết thúc mà |z| vẫn \\le 2: Dãy không tiến ra vô cực (trong giới hạn N lần lặp). Điểm c thuộc tập Mandelbrot.\n\nTô màu:\n\nNếu c thuộc tập Mandelbrot, tô pixel (x, y) màu đen.\nNếu c không thuộc tập Mandelbrot, không tô (để màu trắng) (hoặc tô màu dựa trên số lần lặp i trước khi |z| &gt; 2 để tạo ra các hình ảnh Mandelbrot có màu sắc).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>FRACTAL</span>"
    ]
  }
]